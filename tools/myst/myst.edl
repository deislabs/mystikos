enclave
{
    from "openenclave/edl/sgx/platform.edl" import *;
    from "openenclave/edl/logging.edl" import *;
    from "openenclave/edl/fcntl.edl" import oe_syscall_writev_ocall;
    from "openenclave/edl/fcntl.edl" import oe_syscall_dup_ocall;
    from "openenclave/edl/fcntl.edl" import oe_syscall_readv_ocall;
    from "openenclave/edl/fcntl.edl" import oe_syscall_close_ocall;

    include "time.h"
    include "sys/socket.h"
    include "sys/epoll.h"
    include "sys/eventfd.h"
    include "myst/shm.h"
    include "myst/fssig.h"
    include "myst/blockdevice.h"
    include "myst/options.h"
    include "poll.h"
    include "fcntl.h"

    struct myst_timespec
    {
       long tv_sec;
       long tv_nsec;
    };

    struct myst_stat
    {
        unsigned long st_dev;
        unsigned long st_ino;
        unsigned long st_nlink;
        unsigned int st_mode;
        unsigned int st_uid;
        unsigned int st_gid;
        unsigned int __st_pad0;
        unsigned long st_rdev;
        long st_size;
        long st_blksize;
        long st_blocks;
        struct myst_timespec st_atim;
        struct myst_timespec st_mtim;
        struct myst_timespec st_ctim;
    };

    struct myst_fsid
    {
        int __val[2];
    };

    struct myst_statfs
    {
        unsigned long f_type;
        unsigned long f_bsize;
        unsigned long f_blocks;
        unsigned long f_bfree;
        unsigned long f_bavail;
        unsigned long f_files;
        unsigned long f_ffree;
        struct myst_fsid f_fsid;
        unsigned long f_namelen;
        unsigned long f_frsize;
        unsigned long f_flags;
        unsigned long f_spare[4];
    };


    struct myst_linux_dirent64
    {
        unsigned long d_ino;
        unsigned long d_off;
        unsigned short d_reclen;
        unsigned char d_type;
        char d_name[1];
    };

    struct myst_sched_param_reserved {
        time_t __reserved1;
        long __reserved2;
    };

    /* The expected glibc struct sched_param */
    struct myst_sched_param {
        int sched_priority;
    };

    trusted
    {
        public int myst_enter_ecall(
            [in] struct myst_options* options,
            [in] struct myst_shm* shared_memory,
            [in, size=args_size] const void* args,
            size_t args_size,
            [in, size=env_size] const void* env,
            size_t env_size,
            [in, size=mount_mappings_size] const void* mount_mappings,
            size_t mount_mappings_size,
            uint64_t event,
            pid_t target_tid,
            uint64_t start_time_sec,
            uint64_t start_time_nsec);

        public long myst_run_thread_ecall(
            uint64_t cookie,
            uint64_t event,
            pid_t target_id);
    };

    untrusted
    {
        void myst_rdtsc_ocall([out] uint32_t* rax, [out] uint32_t* rdx);

        long myst_syscall_isatty_ocall(int fd);

        int myst_mprotect_ocall(void* addr, size_t len, int prot);

        /*
        **======================================================================
        **
        ** threading/scheduler
        **
        **======================================================================
        */

        long myst_create_thread_ocall(uint64_t cookie);

        long myst_wait_ocall(
            uint64_t event,
            [in] const struct myst_timespec* timeout);

        long myst_wake_ocall(uint64_t event);

        long myst_wake_wait_ocall(
            uint64_t waiter_event,
            uint64_t self_event,
            [in] const struct myst_timespec* timeout);

        long myst_sched_yield_ocall()
            transition_using_threads;

        long myst_sched_getparam_ocall(
            pid_t pid,
            [out] struct myst_sched_param* param)
            transition_using_threads;

        long myst_poll_ocall(
            [in, out, count=nfds] struct pollfd* fds,
            unsigned long nfds,
            int timeout);

        long myst_poll_wake_ocall();

        long myst_nanosleep_ocall(
            [in] const struct timespec* req,
            [out] struct timespec* rem);

        long myst_epoll_create1_ocall(int flags);

        long myst_epoll_wait_ocall(
            int epfd,
            [out, count=maxevents] struct epoll_event* events,
            size_t maxevents,
            int timeout);

        long myst_epoll_ctl_ocall(
            int epfd,
            int op,
            int fd,
            [in] const struct epoll_event* event);

        long myst_eventfd_ocall(unsigned int initval, int flags);

        long myst_interrupt_thread_ocall(pid_t tid);

        /*
        **======================================================================
        **
        ** socket
        **
        **======================================================================
        */

        long myst_bind_ocall(
            int sockfd,
            [in, size=addrlen] const struct sockaddr* addr,
            socklen_t addrlen);

        long myst_connect_ocall(
            int sockfd,
            [in, size=addrlen] const struct sockaddr* addr,
            socklen_t addrlen)
            transition_using_threads;

        long myst_connect_block_ocall(
            int sockfd,
            [in, size=addrlen] const struct sockaddr* addr,
            socklen_t addrlen);

        long myst_recvfrom_ocall(
            int sockfd,
            [out, size=len] void* buf,
            size_t len,
            int flags,
            [out, size=src_addr_size] struct sockaddr* src_addr,
            [in, out] socklen_t* addrlen_out,
            socklen_t src_addr_size)
            transition_using_threads;

        long myst_recvfrom_block_ocall(
            int sockfd,
            [out, size=len] void* buf,
            size_t len,
            int flags,
            [out, size=src_addr_size] struct sockaddr* src_addr,
            [in, out] socklen_t* addrlen_out,
            socklen_t src_addr_size);

        long myst_sendto_ocall(
            int sockfd,
            [in, size=len] const void* buf,
            size_t len,
            int flags,
            [in, size=addrlen] const struct sockaddr* dest_addr,
            socklen_t addrlen)
            transition_using_threads;

        long myst_sendto_block_ocall(
            int sockfd,
            [in, size=len] const void* buf,
            size_t len,
            int flags,
            [in, size=addrlen] const struct sockaddr* dest_addr,
            socklen_t addrlen);

        long myst_socket_ocall(int domain, int type, int protocol);

        long myst_accept4_ocall(
            int sockfd,
            [out, size=addr_size] struct sockaddr* addr,
            [in, out] socklen_t* addrlen,
            size_t addr_size,
            int flags)
            transition_using_threads;

        long myst_accept4_block_ocall(
            int sockfd,
            [out, size=addr_size] struct sockaddr* addr,
            [in, out] socklen_t* addrlen,
            size_t addr_size,
            int flags);

        long myst_sendmsg_ocall(
            int sockfd,
            /* -- begin struct msghdr -- */
            [in, size=msg_namelen] const void* msg_name,
            socklen_t msg_namelen,
            [in, size=len] const void* buf,
            size_t len,
            [in, size=msg_controllen] const void* msg_control,
            socklen_t msg_controllen,
            int msg_flags,
            /* -- end struct msghdr -- */
            int flags)
            transition_using_threads;

        long myst_sendmsg_block_ocall(
            int sockfd,
            /* -- begin struct msghdr -- */
            [in, size=msg_namelen] const void* msg_name,
            socklen_t msg_namelen,
            [in, size=len] const void* buf,
            size_t len,
            [in, size=msg_controllen] const void* msg_control,
            socklen_t msg_controllen,
            int msg_flags,
            /* -- end struct msghdr -- */
            int flags);

        long myst_recvmsg_ocall(
            int sockfd,
            /* -- begin struct msghdr -- */
            [out, size=msg_namelen] void* msg_name,
            socklen_t msg_namelen,
            [out] socklen_t* msg_namelen_out,
            [out, size=len] void* buf,
            size_t len,
            [out, size=msg_controllen] void* msg_control,
            socklen_t msg_controllen,
            [out] socklen_t* msg_controllen_out,
            [out] int* msg_flags,
            /* -- end struct msghdr -- */
            int flags)
            transition_using_threads;

        long myst_recvmsg_block_ocall(
            int sockfd,
            /* -- begin struct msghdr -- */
            [out, size=msg_namelen] void* msg_name,
            socklen_t msg_namelen,
            [out] socklen_t* msg_namelen_out,
            [out, size=len] void* buf,
            size_t len,
            [out, size=msg_controllen] void* msg_control,
            socklen_t msg_controllen,
            [out] socklen_t* msg_controllen_out,
            [out] int* msg_flags,
            /* -- end struct msghdr -- */
            int flags);

        long myst_shutdown_ocall(int sockfd, int how);

        long myst_listen_ocall(int sockfd, int backlog);

        long myst_getsockname_ocall(
            int sockfd,
            [out, size=addr_size] struct sockaddr* addr,
            [in, out] socklen_t* addrlen,
            socklen_t addr_size);

        long myst_getpeername_ocall(
            int sockfd,
            [out, size=addr_size] struct sockaddr* addr,
            [in, out] socklen_t* addrlen,
            socklen_t addr_size);

        long myst_socketpair_ocall(
            int domain,
            int type,
            int protocol,
            [out] int sv[2]);

        long myst_setsockopt_ocall(
            int sockfd,
            int level,
            int optname,
            [in, size=optlen] const void* optval,
            socklen_t optlen);

        long myst_getsockopt_ocall(
            int sockfd,
            int level,
            int optname,
            [out, size=optval_size] void* optval,
            [in, out] socklen_t* optlen,
            socklen_t optval_size);

        // ATTN: If Host file system support is exclude in certain build mode,
        // consider excluding relevant OCALL proxy code too.

        /*
        **======================================================================
        **
        ** pipe
        **
        **======================================================================
        */

        long myst_pipe2_ocall([out] int pipefd[2], int flags);

        /*
        **======================================================================
        **
        ** hostfs
        **
        **======================================================================
        */

        long myst_ioctl_ocall(
            int fd,
            unsigned long request,
            [in, out, size=argp_size] void* argp,
            size_t argp_size);

        long myst_open_ocall(
            [in, string] const char* pathname,
            int flags,
            mode_t mode,
            uid_t uid,
            gid_t gid);

        long myst_read_ocall(
            int fd,
            [out, size=count] void* buf,
            size_t count)
            transition_using_threads;

        long myst_read_block_ocall(
            int fd,
            [out, size=count] void* buf,
            size_t count);

        long myst_write_ocall(
            int fd,
            [in, size=count] const void* buf,
            size_t count)
            transition_using_threads;

        long myst_write_block_ocall(
            int fd,
            [in, size=count] const void* buf,
            size_t count);

        long myst_close_ocall(int fd);

        long myst_stat_ocall(
            [in, string] const char* pathname,
            [out] struct myst_stat* statbuf,
            uid_t uid,
            gid_t gid);

        long myst_lstat_ocall(
            [in, string] const char* pathname,
            [out] struct myst_stat* statbuf,
            uid_t host_euid,
            gid_t host_egid);

        long myst_fstat_ocall(int fd, [out] struct myst_stat* statbuf);

        long myst_access_ocall(
            [in, string] const char* pathname,
            int mode);

        long myst_dup_ocall(int oldfd);

        long myst_pread64_ocall(
            int fd,
            [out, size=count] void* buf,
            size_t count,
            off_t offset);

        long myst_pwrite64_ocall(
            int fd,
            [in, size=count] const void* buf,
            size_t count,
            off_t offset);

        long myst_link_ocall(
            [in, string] const char* oldpath,
            [in, string] const char* newpath);

        long myst_linkat_ocall(
            int olddirfd,
            [in, string] const char* oldpath,
            int newdirfd,
            [in, string] const char* newpath,
            int flags);

        long myst_unlink_ocall(
            [in, string] const char* pathname);

        long myst_mkdir_ocall(
            [in, string] const char* pathname,
            mode_t mode,
            uid_t host_euid,
            gid_t host_egid);

        long myst_rmdir_ocall(
            [in, string] const char* pathname,
            uid_t host_euid,
            gid_t host_egid);

        long myst_getdents64_ocall(
            unsigned int fd,
            [out, size=count] struct myst_linux_dirent64* dirp,
            unsigned int count);

        long myst_rename_ocall(
            [in, string] const char* oldpath,
            [in, string] const char* newpath);

        long myst_truncate_ocall(
            [in, string] const char* path,
            off_t length);

        long myst_ftruncate_ocall(int fd, off_t length);

        long myst_symlink_ocall(
            [in, string] const char* target,
            [in, string] const char* linkpath,
            uid_t host_euid,
            gid_t host_egid);

        long myst_readlink_ocall(
            [in, string] const char* pathname,
            [out, size=bufsiz] char* buf,
            size_t bufsiz);

        long myst_statfs_ocall(
            [in, string] const char* path,
            [out] struct myst_statfs* buf);

        long myst_fstatfs_ocall(
            int fd,
            [out] struct myst_statfs* buf);

        long myst_lseek_ocall(int fd, off_t offset, int whence);

        long myst_utimensat_ocall(
            int dirfd,
            [in, string] const char* pathname,
            [in] const struct timespec times[2],
            int flags,
            uid_t uid,
            gid_t gid);


        long myst_chown_ocall(
            [in, string] const char* pathname,
            uid_t owner,
            gid_t group,
            uid_t host_euid,
            gid_t host_egid);

        long myst_fchown_ocall(
            int fd,
            uid_t owner,
            gid_t group,
            uid_t host_euid,
            gid_t host_egid);

        long myst_lchown_ocall(
            [in, string] const char* pathname,
            uid_t owner,
            gid_t group,
            uid_t host_euid,
            gid_t host_egid
        );

        long myst_chmod_ocall(
            [in, string] const char* pathname,
            mode_t mode,
            uid_t host_euid,
            gid_t host_egid);

        long myst_fchmod_ocall(
            int fd,
            uint32_t mode,
            uid_t host_euid,
            gid_t host_egid);

        long myst_fcntl_ocall(int fd, int cmd, long arg);

        long myst_fcntl_setlkw_ocall(int fd, [in] const struct flock* arg);

        // ATTN: If debugging support is excluded in certain build mode,
        // consider excluding relevant OCALL proxy code too.

        /*
        **======================================================================
        **
        ** debugger
        **
        **======================================================================
        */

        int myst_add_symbol_file_ocall(
            [in, size=file_size] const void* file_data,
            size_t file_size,
            [user_check] const void* text_data,
            size_t text_size,
            [in, string] const char* enclave_rootfs_path);

        int myst_load_symbols_ocall();

        int myst_unload_symbols_ocall();

        // ATTN: If EXT2 file system support is exlcuded in certain build mode,
        // consider excluding relevant OCALL proxy code too.

        long myst_fdatasync_ocall(int fd);

        long myst_fsync_ocall(int fd);

        /*
        **======================================================================
        **
        ** block devices
        **
        **======================================================================
        */

        /* returns a handle to the block device */
        int myst_open_block_device_ocall(
            [in, string] const char* path,
            bool read_only);

        /* closes a block device */
        int myst_close_block_device_ocall(int blkdev);

        /* writes to the block device */
        int myst_write_block_device_ocall(
            int blkdev,
            uint64_t blkno,
            [in, count=num_blocks] const struct myst_block* blocks,
            size_t num_blocks)
            transition_using_threads;

        /* reads from the block device */
        ssize_t myst_read_block_device_ocall(
            int blkdev,
            uint64_t blkno,
            [out, count=num_blocks] struct myst_block* blocks,
            size_t num_blocks)
            transition_using_threads;

        /* load the file-system signature structure from the given image */
        int myst_load_fssig_ocall(
            [in, string] const char* path,
            [out] myst_fssig_t* fssig);

        /*
        **======================================================================
        **
        ** processor
        **
        **======================================================================
        */

        long myst_getcpu_ocall(
            [out] unsigned* cpu,
            [out] unsigned* node);

        long myst_sched_setaffinity_ocall(
            pid_t pid,
            size_t cpusetsize,
            [in, size=cpusetsize] const uint8_t* mask);

        long myst_sched_getaffinity_ocall(
            pid_t pid,
            size_t cpusetsize,
            [in, out, size=cpusetsize] uint8_t* mask);

        void myst_cpuid_ocall(
            uint32_t leaf,
            uint32_t subleaf,
            [out] uint32_t* rax,
            [out] uint32_t* rbx,
            [out] uint32_t* rcx,
            [out] uint32_t* rdx);

        /*
        **======================================================================
        **
        ** console I/O
        **
        **======================================================================
        */

        long myst_write_console_ocall(
            int fd, /* STDOUT_FILENO or STDERR_FILENO */
            [in, size=count] const void* buf,
            size_t count);
    };
};
