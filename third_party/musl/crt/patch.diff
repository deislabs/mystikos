diff --git a/Makefile b/Makefile
index bd8f5c38..ed57984d 100644
--- a/Makefile
+++ b/Makefile
@@ -160,12 +160,17 @@ obj/%.lo: $(srcdir)/%.c $(GENH) $(IMPH)
 lib/libc.so: $(LOBJS) $(LDSO_OBJS)
 	$(CC) $(CFLAGS_ALL) $(LDFLAGS_ALL) -nostdlib -shared \
 	-Wl,-e,_dlstart -o $@ $(LOBJS) $(LDSO_OBJS) $(LIBCC)
+	$(MAKE) objects.mak
 
 lib/libc.a: $(AOBJS)
 	rm -f $@
 	$(AR) rc $@ $(AOBJS)
 	$(RANLIB) $@
 
+objects.mak: $(LOBJS) $(LDSO_OBJS)
+	@ echo "MUSL_OBJECTS = $(addprefix <CURDIR>/,$(LOBJS) $(LDSO_OBJS))" > objects.mak
+	@ sed -i 's|<CURDIR>|$(CURDIR)|g' objects.mak
+
 $(EMPTY_LIBS):
 	rm -f $@
 	$(AR) rc $@
diff --git a/arch/x86_64/syscall_arch.h b/arch/x86_64/syscall_arch.h
index 92d5c179..e94deece 100644
--- a/arch/x86_64/syscall_arch.h
+++ b/arch/x86_64/syscall_arch.h
@@ -1,64 +1,69 @@
 #define __SYSCALL_LL_E(x) (x)
 #define __SYSCALL_LL_O(x) (x)
 
+long myst_syscall(long n, long params[6]);
+
 static __inline long __syscall0(long n)
 {
-	unsigned long ret;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n) : "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    return myst_syscall(n, params);
 }
 
 static __inline long __syscall1(long n, long a1)
 {
-	unsigned long ret;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1) : "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    params[0] = a1;
+    return myst_syscall(n, params);
 }
 
 static __inline long __syscall2(long n, long a1, long a2)
 {
-	unsigned long ret;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2)
-						  : "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    params[0] = a1;
+    params[1] = a2;
+    return myst_syscall(n, params);
 }
 
 static __inline long __syscall3(long n, long a1, long a2, long a3)
 {
-	unsigned long ret;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
-						  "d"(a3) : "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    params[0] = a1;
+    params[1] = a2;
+    params[2] = a3;
+    return myst_syscall(n, params);
 }
 
 static __inline long __syscall4(long n, long a1, long a2, long a3, long a4)
 {
-	unsigned long ret;
-	register long r10 __asm__("r10") = a4;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
-						  "d"(a3), "r"(r10): "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    params[0] = a1;
+    params[1] = a2;
+    params[2] = a3;
+    params[3] = a4;
+    return myst_syscall(n, params);
 }
 
 static __inline long __syscall5(long n, long a1, long a2, long a3, long a4, long a5)
 {
-	unsigned long ret;
-	register long r10 __asm__("r10") = a4;
-	register long r8 __asm__("r8") = a5;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
-						  "d"(a3), "r"(r10), "r"(r8) : "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    params[0] = a1;
+    params[1] = a2;
+    params[2] = a3;
+    params[3] = a4;
+    params[4] = a5;
+    return myst_syscall(n, params);
 }
 
 static __inline long __syscall6(long n, long a1, long a2, long a3, long a4, long a5, long a6)
 {
-	unsigned long ret;
-	register long r10 __asm__("r10") = a4;
-	register long r8 __asm__("r8") = a5;
-	register long r9 __asm__("r9") = a6;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
-						  "d"(a3), "r"(r10), "r"(r8), "r"(r9) : "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    params[0] = a1;
+    params[1] = a2;
+    params[2] = a3;
+    params[3] = a4;
+    params[4] = a5;
+    params[5] = a6;
+    return myst_syscall(n, params);
 }
 
 #define VDSO_USEFUL
diff --git a/include/math.h b/include/math.h
index 14f28ec8..09b5790d 100644
--- a/include/math.h
+++ b/include/math.h
@@ -413,10 +413,12 @@ float       lgammaf_r(float, int*);
 float       j0f(float);
 float       j1f(float);
 float       jnf(int, float);
+double      jnl(int n, double x);
 
 float       y0f(float);
 float       y1f(float);
 float       ynf(int, float);
+double      ynl(int n, double x);
 #endif
 
 #ifdef _GNU_SOURCE
diff --git a/include/pthread.h b/include/pthread.h
index 984db680..9adecf2b 100644
--- a/include/pthread.h
+++ b/include/pthread.h
@@ -222,6 +222,10 @@ int pthread_getattr_default_np(pthread_attr_t *);
 int pthread_setattr_default_np(const pthread_attr_t *);
 int pthread_tryjoin_np(pthread_t, void **);
 int pthread_timedjoin_np(pthread_t, void **, const struct timespec *);
+int pthread_attr_setaffinity_np(pthread_attr_t *a,
+         size_t cpusetsize, const cpu_set_t *cpuset);
+int pthread_attr_getaffinity_np(pthread_attr_t *a,
+         size_t cpusetsize, cpu_set_t *cpuset);
 #endif
 
 #if _REDIR_TIME64
diff --git a/include/semaphore.h b/include/semaphore.h
index 3690f496..5e7185bf 100644
--- a/include/semaphore.h
+++ b/include/semaphore.h
@@ -14,6 +14,8 @@ extern "C" {
 
 #define SEM_FAILED ((sem_t *)0)
 
+typedef int clockid_t;
+
 typedef struct {
 	volatile int __val[4*sizeof(long)/sizeof(int)];
 } sem_t;
@@ -25,6 +27,7 @@ int    sem_init(sem_t *, int, unsigned);
 sem_t *sem_open(const char *, int, ...);
 int    sem_post(sem_t *);
 int    sem_timedwait(sem_t *__restrict, const struct timespec *__restrict);
+int    sem_clockwait(sem_t *__restrict, clockid_t, const struct timespec *__restrict);
 int    sem_trywait(sem_t *);
 int    sem_unlink(const char *);
 int    sem_wait(sem_t *);
diff --git a/include/sys/ioctl.h b/include/sys/ioctl.h
index c2ce3b48..30de25bb 100644
--- a/include/sys/ioctl.h
+++ b/include/sys/ioctl.h
@@ -117,7 +117,7 @@ struct winsize {
 #define SIOCDEVPRIVATE     0x89F0
 #define SIOCPROTOPRIVATE   0x89E0
 
-int ioctl (int, int, ...);
+int ioctl (int, unsigned long, ...);
 
 #ifdef __cplusplus
 }
diff --git a/ldso/dlstart.c b/ldso/dlstart.c
index 20d50f2c..17cd6ac3 100644
--- a/ldso/dlstart.c
+++ b/ldso/dlstart.c
@@ -1,4 +1,9 @@
+#include <elf.h>
+#include <errno.h>
 #include <stddef.h>
+#include <stdbool.h>
+#include <syscall.h>
+#include <sys/mman.h>
 #include "dynlink.h"
 #include "libc.h"
 
@@ -124,7 +129,6 @@ hidden void _dlstart_c(size_t *sp, size_t *dynv)
 			local_cnt = dynv[i+1];
 		for (i=0; i<local_cnt; i++) got[i] += base;
 	}
-
 	rel = (void *)(base+dyn[DT_REL]);
 	rel_size = dyn[DT_RELSZ];
 	for (; rel_size; rel+=2, rel_size-=2*sizeof(size_t)) {
@@ -146,3 +150,45 @@ hidden void _dlstart_c(size_t *sp, size_t *dynv)
 	GETFUNCSYM(&dls2, __dls2, base+dyn[DT_PLTGOT]);
 	dls2((void *)base, sp);
 }
+
+__attribute__((__weak__))
+void myst_trace(const char* msg)
+{
+}
+
+__attribute__((__weak__))
+void myst_trace_ptr(const char* msg, const void* ptr)
+{
+}
+
+__attribute__((__weak__))
+void myst_dump_argv(int argc, const char* argv[])
+{
+}
+
+__attribute__((__weak__))
+void myst_dump_stack(const void* stack)
+{
+}
+
+__attribute__((__weak__))
+void myst_load_symbols(void)
+{
+}
+
+__attribute__((__weak__))
+long myst_add_symbol_file(const char* path, const void* text, size_t text_size)
+{
+    return -ENOTSUP;
+}
+
+__attribute__((__weak__))
+bool myst_get_exec_stack_option()
+{
+    return false;
+}
+
+__attribute__((__weak__))
+void myst_get_current_stack(void** stack, size_t* stack_size)
+{
+}
diff --git a/ldso/dynlink.c b/ldso/dynlink.c
index afec985a..9f9b618d 100644
--- a/ldso/dynlink.c
+++ b/ldso/dynlink.c
@@ -3,6 +3,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
+#include <stdbool.h>
 #include <stddef.h>
 #include <string.h>
 #include <unistd.h>
@@ -27,12 +28,30 @@
 
 static void error(const char *, ...);
 
+void myst_trace(const char* msg);
+void myst_load_symbols(void);
+long myst_add_symbol_file(
+    const char* path,
+    const void* text,
+    size_t text_size);
+bool myst_get_exec_stack_option();
+void myst_get_current_stack();
+
+/* Allow Mystikos to perform tasks right before the app is launched. */
+__attribute__((__weak__))
+int myst_pre_launch_hook()
+{
+    return -ENOTSUP;
+}
+
 #define MAXP2(a,b) (-(-(a)&-(b)))
 #define ALIGN(x,y) ((x)+(y)-1 & -(y))
 
 #define container_of(p,t,m) ((t*)((char *)(p)-offsetof(t,m)))
 #define countof(a) ((sizeof (a))/(sizeof (a)[0]))
 
+#define SYS_mprotect 10
+
 struct debug {
 	int ver;
 	void *head;
@@ -217,6 +236,14 @@ static int search_vec(size_t *v, size_t *r, size_t key)
 	return 1;
 }
 
+static size_t* find_dynv_value_addr_by_key(size_t *v, size_t *r, size_t key)
+{
+	for (; v[0]!=key; v+=2)
+		if (!v[0]) return 0;
+	*r = v[1];
+	return &v[1];
+}
+
 static uint32_t sysv_hash(const char *s0)
 {
 	const unsigned char *s = (void *)s0;
@@ -658,6 +685,25 @@ static void *map_library(int fd, struct dso *dso)
 					ph->p_memsz < DEFAULT_STACK_MAX ?
 					ph->p_memsz : DEFAULT_STACK_MAX;
 			}
+			if (myst_get_exec_stack_option()) {
+				int prot_flags = 0;
+				if (ph->p_flags & PF_X)
+					prot_flags |= PROT_EXEC;
+				
+				if (ph->p_flags & PF_W)
+					prot_flags |= PROT_WRITE;
+				
+				if (ph->p_flags & PF_R)
+					prot_flags |= PROT_READ;
+				
+				void *stack_p = 0;
+				size_t *stack_size = 0;
+				myst_get_current_stack(&stack_p, &stack_size);
+				if (stack_p && stack_size)
+				{
+					syscall(SYS_mprotect, stack_p, stack_size, prot_flags);
+				}
+			}
 		}
 		if (ph->p_type != PT_LOAD) continue;
 		nsegs++;
@@ -895,6 +941,7 @@ static int fixup_rpath(struct dso *p, char *buf, size_t buf_size)
 static void decode_dyn(struct dso *p)
 {
 	size_t dyn[DYN_CNT];
+	size_t* dynval_ptr = 0;
 	decode_vec(p->dynv, dyn, DYN_CNT);
 	p->syms = laddr(p, dyn[DT_SYMTAB]);
 	p->strings = laddr(p, dyn[DT_STRTAB]);
@@ -906,8 +953,21 @@ static void decode_dyn(struct dso *p)
 		p->rpath_orig = p->strings + dyn[DT_RUNPATH];
 	if (dyn[0]&(1<<DT_PLTGOT))
 		p->got = laddr(p, dyn[DT_PLTGOT]);
-	if (search_vec(p->dynv, dyn, DT_GNU_HASH))
+	if ((dynval_ptr = find_dynv_value_addr_by_key(p->dynv, dyn, DT_GNU_HASH)))
+	{
 		p->ghashtab = laddr(p, *dyn);
+		// patch the address in the original dynamic section.
+		*dynval_ptr = (size_t)p->ghashtab;
+	}
+	// patch addresses for symbol and string sections too
+	if ((dynval_ptr = find_dynv_value_addr_by_key(p->dynv, dyn, DT_SYMTAB)))
+	{
+		*dynval_ptr = (size_t)p->syms;
+	}
+	if ((dynval_ptr = find_dynv_value_addr_by_key(p->dynv, dyn, DT_STRTAB)))
+	{
+		*dynval_ptr = (size_t)p->strings;
+	}
 	if (search_vec(p->dynv, dyn, DT_VERSYM))
 		p->versym = laddr(p, *dyn);
 }
@@ -1043,38 +1103,7 @@ static struct dso *load_library(const char *name, struct dso *needed_by)
 				fd = path_open(name, p->rpath, buf, sizeof buf);
 		}
 		if (fd == -1) {
-			if (!sys_path) {
-				char *prefix = 0;
-				size_t prefix_len;
-				if (ldso.name[0]=='/') {
-					char *s, *t, *z;
-					for (s=t=z=ldso.name; *s; s++)
-						if (*s=='/') z=t, t=s;
-					prefix_len = z-ldso.name;
-					if (prefix_len < PATH_MAX)
-						prefix = ldso.name;
-				}
-				if (!prefix) {
-					prefix = "";
-					prefix_len = 0;
-				}
-				char etc_ldso_path[prefix_len + 1
-					+ sizeof "/etc/ld-musl-" LDSO_ARCH ".path"];
-				snprintf(etc_ldso_path, sizeof etc_ldso_path,
-					"%.*s/etc/ld-musl-" LDSO_ARCH ".path",
-					(int)prefix_len, prefix);
-				FILE *f = fopen(etc_ldso_path, "rbe");
-				if (f) {
-					if (getdelim(&sys_path, (size_t[1]){0}, 0, f) <= 0) {
-						free(sys_path);
-						sys_path = "";
-					}
-					fclose(f);
-				} else if (errno != ENOENT) {
-					sys_path = "";
-				}
-			}
-			if (!sys_path) sys_path = "/lib:/usr/local/lib:/usr/lib";
+			if (!sys_path) sys_path = "/lib:/usr/local/lib:/usr/lib:/usr/lib/x86_64-linux-gnu:/lib/x86_64-linux-gnu";
 			fd = path_open(name, sys_path, buf, sizeof buf);
 		}
 		pathname = buf;
@@ -1098,6 +1127,7 @@ static struct dso *load_library(const char *name, struct dso *needed_by)
 	map = noload ? 0 : map_library(fd, &temp_dso);
 	close(fd);
 	if (!map) return 0;
+	myst_add_symbol_file(pathname, temp_dso.map, temp_dso.map_len);
 
 	/* Avoid the danger of getting two versions of libc mapped into the
 	 * same process when an absolute pathname was used. The symbols
@@ -1683,6 +1713,13 @@ void __dls2b(size_t *sp, size_t *auxv)
 	else ((stage3_func)laddr(&ldso, dls3_def.sym->st_value))(sp, auxv);
 }
 
+/* override this to allow LD_PRELOAD */
+__attribute__((__weak__))
+int allow_ld_preload(void)
+{
+    return 0;
+}
+
 /* Stage 3 of the dynamic linker is called with the dynamic linker/libc
  * fully functional. Its job is to load (if not already loaded) and
  * process dependencies and relocations for the main application and
@@ -1716,6 +1753,10 @@ void __dls3(size_t *sp, size_t *auxv)
 		env_path = getenv("LD_LIBRARY_PATH");
 		env_preload = getenv("LD_PRELOAD");
 	}
+        else if (allow_ld_preload())
+        {
+		env_preload = getenv("LD_PRELOAD");
+        }
 
 	/* If the main program was already loaded by the kernel,
 	 * AT_PHDR will point to some location other than the dynamic
@@ -1797,6 +1838,7 @@ void __dls3(size_t *sp, size_t *auxv)
 			dprintf(2, "%s: %s: Not a valid dynamic program\n", ldname, argv[0]);
 			_exit(1);
 		}
+	        myst_add_symbol_file(argv[0], app.map, app.map_len);
 		close(fd);
 		ldso.name = ldname;
 		app.name = argv[0];
@@ -1936,6 +1978,7 @@ void __dls3(size_t *sp, size_t *auxv)
 	/* Determine if malloc was interposed by a replacement implementation
 	 * so that calloc and the memalign family can harden against the
 	 * possibility of incomplete replacement. */
+
 	if (find_sym(head, "malloc", 1).dso != &ldso)
 		__malloc_replaced = 1;
 
@@ -1955,7 +1998,13 @@ void __dls3(size_t *sp, size_t *auxv)
 
 	errno = 0;
 
+  myst_trace("entering program");
+  myst_load_symbols();
+
+  myst_pre_launch_hook();
+
 	CRTJMP((void *)aux[AT_ENTRY], argv-1);
+
 	for(;;);
 }
 
@@ -2058,6 +2107,10 @@ void *dlopen(const char *file, int mode)
 	pthread_mutex_lock(&init_fini_lock);
 	if (!p->constructed) ctor_queue = queue_ctors(p);
 	pthread_mutex_unlock(&init_fini_lock);
+
+  // Update static_tls_cnt for the subsequent relocations
+  static_tls_cnt = tls_cnt;
+
 	if (!p->relocated && (mode & RTLD_LAZY)) {
 		prepare_lazy(p);
 		for (i=0; p->deps[i]; i++)
@@ -2100,6 +2153,7 @@ end:
 		free(ctor_queue);
 	}
 	pthread_setcancelstate(cs, 0);
+        myst_load_symbols();
 	return p;
 }
 
@@ -2272,11 +2326,16 @@ no_redir:
 	return __dlsym(p, s, ra);
 }
 
+/* Lock to keep calls to callbacks thread-safe. 
+ * Passed callbacks may have static members. */
+static pthread_mutex_t dl_iterate_cb_lock;
 int dl_iterate_phdr(int(*callback)(struct dl_phdr_info *info, size_t size, void *data), void *data)
 {
 	struct dso *current;
 	struct dl_phdr_info info;
 	int ret = 0;
+
+	pthread_rwlock_wrlock(&lock);
 	for(current = head; current;) {
 		info.dlpi_addr      = (uintptr_t)current->base;
 		info.dlpi_name      = current->name;
@@ -2289,12 +2348,11 @@ int dl_iterate_phdr(int(*callback)(struct dl_phdr_info *info, size_t size, void
 
 		ret = (callback)(&info, sizeof (info), data);
 
-		if (ret != 0) break;
+		if (ret != 0) break; 
 
-		pthread_rwlock_rdlock(&lock);
 		current = current->next;
-		pthread_rwlock_unlock(&lock);
 	}
+	pthread_rwlock_unlock(&lock);
 	return ret;
 }
 
@@ -2302,7 +2360,7 @@ static void error(const char *fmt, ...)
 {
 	va_list ap;
 	va_start(ap, fmt);
-	if (!runtime) {
+	if (!runtime || getenv("REPORT_MUSL_LOADER_ERROR")) {
 		vdprintf(2, fmt, ap);
 		dprintf(2, "\n");
 		ldso_fail = 1;
diff --git a/src/conf/confstr.c b/src/conf/confstr.c
index 02cb1aa2..07e76f19 100644
--- a/src/conf/confstr.c
+++ b/src/conf/confstr.c
@@ -7,6 +7,8 @@ size_t confstr(int name, char *buf, size_t len)
 	const char *s = "";
 	if (!name) {
 		s = "/bin:/usr/bin";
+	} else if (name == _CS_GNU_LIBC_VERSION) {
+		s = "glibc 2.27";
 	} else if ((name&~4U)!=1 && name-_CS_POSIX_V6_ILP32_OFF32_CFLAGS>33U) {
 		errno = EINVAL;
 		return 0;
diff --git a/src/conf/fpathconf.c b/src/conf/fpathconf.c
index e6aca5cf..a4ed5482 100644
--- a/src/conf/fpathconf.c
+++ b/src/conf/fpathconf.c
@@ -1,6 +1,7 @@
 #include <unistd.h>
 #include <limits.h>
 #include <errno.h>
+#include <sys/stat.h>
 
 long fpathconf(int fd, int name)
 {
@@ -31,5 +32,15 @@ long fpathconf(int fd, int name)
 		errno = EINVAL;
 		return -1;
 	}
+
+	// The maximum length of a filename in the directory path or
+	// fd that the process is allowed to create
+	if (name == _PC_NAME_MAX) {
+		struct stat buf;
+		if (fstat(fd, &buf) == -1) {
+			return -1;
+		}
+	}
+
 	return values[name];
 }
diff --git a/src/conf/pathconf.c b/src/conf/pathconf.c
index 01e19c59..11084aee 100644
--- a/src/conf/pathconf.c
+++ b/src/conf/pathconf.c
@@ -1,6 +1,46 @@
 #include <unistd.h>
+#include <limits.h>
+#include <errno.h>
+#include <sys/stat.h>
 
 long pathconf(const char *path, int name)
 {
-	return fpathconf(-1, name);
+	static const short values[] = {
+		[_PC_LINK_MAX] = _POSIX_LINK_MAX,
+		[_PC_MAX_CANON] = _POSIX_MAX_CANON,
+		[_PC_MAX_INPUT] = _POSIX_MAX_INPUT,
+		[_PC_NAME_MAX] = NAME_MAX,
+		[_PC_PATH_MAX] = PATH_MAX,
+		[_PC_PIPE_BUF] = PIPE_BUF,
+		[_PC_CHOWN_RESTRICTED] = 1,
+		[_PC_NO_TRUNC] = 1,
+		[_PC_VDISABLE] = 0,
+		[_PC_SYNC_IO] = 1,
+		[_PC_ASYNC_IO] = -1,
+		[_PC_PRIO_IO] = -1,
+		[_PC_SOCK_MAXBUF] = -1,
+		[_PC_FILESIZEBITS] = FILESIZEBITS,
+		[_PC_REC_INCR_XFER_SIZE] = 4096,
+		[_PC_REC_MAX_XFER_SIZE] = 4096,
+		[_PC_REC_MIN_XFER_SIZE] = 4096,
+		[_PC_REC_XFER_ALIGN] = 4096,
+		[_PC_ALLOC_SIZE_MIN] = 4096,
+		[_PC_SYMLINK_MAX] = -1,
+		[_PC_2_SYMLINKS] = 1
+	};
+	if (name >= sizeof(values)/sizeof(values[0])) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	// The maximum length of a filename in the directory path or
+	// fd that the process is allowed to create
+	if (name == _PC_NAME_MAX) {
+		struct stat buf;
+		if (stat(path, &buf) == -1) {
+			return -1;
+		}
+	}
+
+	return values[name];
 }
diff --git a/src/errno/__strerror.h b/src/errno/__strerror.h
index 2f04d400..7905ce1b 100644
--- a/src/errno/__strerror.h
+++ b/src/errno/__strerror.h
@@ -102,4 +102,4 @@ E(ENOMEDIUM,    "No medium found")
 E(EMEDIUMTYPE,  "Wrong medium type")
 E(EMULTIHOP,    "Multihop attempted")
 
-E(0,            "No error information")
+E(0,            "Unknown error")
diff --git a/src/exit/_Exit.c b/src/exit/_Exit.c
index 7a6115c7..9f715d51 100644
--- a/src/exit/_Exit.c
+++ b/src/exit/_Exit.c
@@ -1,8 +1,10 @@
 #include <stdlib.h>
 #include "syscall.h"
 
-_Noreturn void _Exit(int ec)
+_Noreturn void do_crt__Exit(int ec)
 {
 	__syscall(SYS_exit_group, ec);
 	for (;;) __syscall(SYS_exit, ec);
 }
+
+_Noreturn weak_alias(do_crt__Exit, _Exit);
diff --git a/src/exit/exit.c b/src/exit/exit.c
index a6869b37..a312428b 100644
--- a/src/exit/exit.c
+++ b/src/exit/exit.c
@@ -24,10 +24,13 @@ static void libc_exit_fini(void)
 
 weak_alias(libc_exit_fini, __libc_exit_fini);
 
-_Noreturn void exit(int code)
+
+_Noreturn void do_crt_exit(int code)
 {
 	__funcs_on_exit();
 	__libc_exit_fini();
 	__stdio_exit();
 	_Exit(code);
 }
+
+_Noreturn weak_alias(do_crt_exit, exit);
diff --git a/src/fcntl/fcntl.c b/src/fcntl/fcntl.c
index d3bff5c4..be23a7f5 100644
--- a/src/fcntl/fcntl.c
+++ b/src/fcntl/fcntl.c
@@ -46,3 +46,5 @@ int fcntl(int fd, int cmd, ...)
 		return syscall(SYS_fcntl, fd, cmd, arg);
 	}
 }
+
+weak_alias(fcntl, fcntl64);
\ No newline at end of file
diff --git a/src/fcntl/open.c b/src/fcntl/open.c
index 1d817a2d..a36ba05e 100644
--- a/src/fcntl/open.c
+++ b/src/fcntl/open.c
@@ -21,3 +21,4 @@ int open(const char *filename, int flags, ...)
 }
 
 weak_alias(open, open64);
+weak_alias(open, __open_nocancel);
diff --git a/src/fenv/feupdateenv.c b/src/fenv/feupdateenv.c
index 50cef8e5..803a7f8d 100644
--- a/src/fenv/feupdateenv.c
+++ b/src/fenv/feupdateenv.c
@@ -7,3 +7,13 @@ int feupdateenv(const fenv_t *envp)
 	feraiseexcept(ex);
 	return 0;
 }
+
+int feenableexcept(int excepts)
+{
+	return 0;
+}
+
+int fedisableexcept(int excepts)
+{
+	return 0;
+}
diff --git a/src/include/pthread.h b/src/include/pthread.h
index 7167d3e1..9deca8e7 100644
--- a/src/include/pthread.h
+++ b/src/include/pthread.h
@@ -16,8 +16,8 @@ hidden int __pthread_mutex_timedlock(pthread_mutex_t *restrict, const struct tim
 hidden int __pthread_mutex_unlock(pthread_mutex_t *);
 hidden int __private_cond_signal(pthread_cond_t *, int);
 hidden int __pthread_cond_timedwait(pthread_cond_t *restrict, pthread_mutex_t *restrict, const struct timespec *restrict);
-hidden int __pthread_key_create(pthread_key_t *, void (*)(void *));
-hidden int __pthread_key_delete(pthread_key_t);
+int __pthread_key_create(pthread_key_t *, void (*)(void *));
+int __pthread_key_delete(pthread_key_t);
 hidden int __pthread_rwlock_rdlock(pthread_rwlock_t *);
 hidden int __pthread_rwlock_tryrdlock(pthread_rwlock_t *);
 hidden int __pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict);
diff --git a/src/include/string.h b/src/include/string.h
index 2133b5c1..cfa2044d 100644
--- a/src/include/string.h
+++ b/src/include/string.h
@@ -4,8 +4,8 @@
 #include "../../include/string.h"
 
 hidden void *__memrchr(const void *, int, size_t);
-hidden char *__stpcpy(char *, const char *);
-hidden char *__stpncpy(char *, const char *, size_t);
+char *__stpcpy(char *, const char *);
+char *__stpncpy(char *, const char *, size_t);
 hidden char *__strchrnul(const char *, int);
 
 #endif
diff --git a/src/include/time.h b/src/include/time.h
index cbabde47..e78515e4 100644
--- a/src/include/time.h
+++ b/src/include/time.h
@@ -3,13 +3,13 @@
 
 #include "../../include/time.h"
 
-hidden int __clock_gettime(clockid_t, struct timespec *);
-hidden int __clock_nanosleep(clockid_t, int, const struct timespec *, struct timespec *);
+int __clock_gettime(clockid_t, struct timespec *);
+int __clock_nanosleep(clockid_t, int, const struct timespec *, struct timespec *);
 
 hidden char *__asctime_r(const struct tm *, char *);
-hidden struct tm *__gmtime_r(const time_t *restrict, struct tm *restrict);
+struct tm *__gmtime_r(const time_t *restrict, struct tm *restrict);
 hidden struct tm *__localtime_r(const time_t *restrict, struct tm *restrict);
 
-hidden size_t __strftime_l(char *restrict, size_t, const char *restrict, const struct tm *restrict, locale_t);
+size_t __strftime_l(char *restrict, size_t, const char *restrict, const struct tm *restrict, locale_t);
 
 #endif
diff --git a/src/internal/pthread_impl.h b/src/internal/pthread_impl.h
index 5742dfc5..fe718786 100644
--- a/src/internal/pthread_impl.h
+++ b/src/internal/pthread_impl.h
@@ -75,7 +75,9 @@ struct __timer {
 #define _a_sched __u.__i[3*__SU+1]
 #define _a_policy __u.__i[3*__SU+2]
 #define _a_prio __u.__i[3*__SU+3]
-#define _m_type __u.__i[0]
+#define _a_cpuset __u.__s[5]
+#define _a_cpusetsize __u.__s[6]
+//#define _m_type __u.__i[0]
 #define _m_lock __u.__vi[1]
 #define _m_waiters __u.__vi[2]
 #define _m_prev __u.__p[3]
@@ -98,6 +100,61 @@ struct __timer {
 #define _b_waiters2 __u.__vi[4]
 #define _b_inst __u.__p[3]
 
+static __inline__ int _m_get_type(pthread_mutex_t* m)
+{
+    // The mutex type is given by or-ing the first and fifth 32-bit words of
+    // the mutex. The type is either set statically by a structure initializer
+    // or dynamically by pthread_mutex_init(). There are three cases:
+    //
+    //     1. The mutex is statically initialized by glibc, where the fifth
+    //        word contains the mutex type and the first word is zero.
+    //     2. The mutex is statically initialized by musl libc, where the
+    //        first word contains the mutex type and the fifth word is zero.
+    //     3. The mutex is dynamically initialized during pthread_mutex_init(),
+    //        where the first word contains the type and the fifth word is zero.
+    //
+    // Static initialization examples:
+    //
+    //     1. PTHREAD_MUTEX_INITIALIZER compiled with musl libc
+    //            m->__u.__i[0] is zero
+    //            m->__u.__i[4] is zero
+    //     2. PTHREAD_MUTEX_INITIALIZER compiled with glibc
+    //            m->__u.__i[0] is zero
+    //            m->__u.__i[4] contains PTHREAD_MUTEX_NORMAL (0)
+    //     3. PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP compiled with glibc
+    //            m->__u.__i[0] is zero
+    //            m->__u.__i[4] contains PTHREAD_MUTEX_RECURSIVE (1)
+    //     4. PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP compiled with glibc
+    //            m->__u.__i[0] is zero
+    //            m->__u.__i[4] contains PTHREAD_MUTEX_ERRORCHECK (2)
+    //     5. PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP compiled with glibc
+    //            m->__u.__i[0] is zero
+    //            m->__u.__i[4] contains PTHREAD_MUTEX_ADAPTIVE_NP (3)
+    //
+    // Note: must libc does not support PTHREAD_MUTEX_ADAPTIVE_NP.
+    //
+    // Note: that musl libc never uses the fourth and fifth words and keeps them
+    // as zero.
+
+    switch (m->__u.__i[4])
+    {
+        case PTHREAD_MUTEX_RECURSIVE:
+            return m->__u.__i[0] | PTHREAD_MUTEX_RECURSIVE;
+        case PTHREAD_MUTEX_ERRORCHECK:
+            return m->__u.__i[0] | PTHREAD_MUTEX_ERRORCHECK;
+        default:
+        {
+            // map glibc PTHREAD_MUTEX_ADAPTIVE_NP to PTHREAD_MUTEX_NORMAL
+            return m->__u.__i[0];
+        }
+    }
+}
+
+static __inline__ int _m_set_type(pthread_mutex_t* m, int type)
+{
+    m->__u.__i[0] = type;
+}
+
 #include "pthread_arch.h"
 
 #ifndef CANARY
diff --git a/src/linux/epoll.c b/src/linux/epoll.c
index deff5b10..fd66b82a 100644
--- a/src/linux/epoll.c
+++ b/src/linux/epoll.c
@@ -5,6 +5,11 @@
 
 int epoll_create(int size)
 {
+        if (size < 0)
+        {
+            errno = EINVAL;
+            return -1;
+        }
 	return epoll_create1(0);
 }
 
diff --git a/src/locale/newlocale.c b/src/locale/newlocale.c
index d20a8489..51b85f20 100644
--- a/src/locale/newlocale.c
+++ b/src/locale/newlocale.c
@@ -19,7 +19,9 @@ int __loc_is_allocated(locale_t loc)
 		&& loc != &default_locale && loc != &default_ctype_locale;
 }
 
-locale_t __newlocale(int mask, const char *name, locale_t loc)
+// libstdc++ uses __newlocale which needs to be wrapped by gcompat layer.
+// Hence, distinguish the musl implementation of __newlocale with _musl suffix.
+locale_t __newlocale_musl(int mask, const char *name, locale_t loc)
 {
 	struct __locale_struct tmp;
 
@@ -54,5 +56,3 @@ locale_t __newlocale(int mask, const char *name, locale_t loc)
 
 	return loc;
 }
-
-weak_alias(__newlocale, newlocale);
diff --git a/src/malloc/malloc.c b/src/malloc/malloc.c
index 96982596..e488c8eb 100644
--- a/src/malloc/malloc.c
+++ b/src/malloc/malloc.c
@@ -281,7 +281,7 @@ static void trim(struct chunk *self, size_t n)
 	__bin_chunk(split);
 }
 
-void *malloc(size_t n)
+void *libc_malloc(size_t n)
 {
 	struct chunk *c;
 	int i, j;
@@ -348,7 +348,8 @@ static size_t mal0_clear(char *p, size_t pagesz, size_t n)
 	}
 }
 
-void *calloc(size_t m, size_t n)
+__attribute__((__weak__))
+void *libc_calloc(size_t m, size_t n)
 {
 	if (n && m > (size_t)-1/n) {
 		errno = ENOMEM;
@@ -366,7 +367,7 @@ void *calloc(size_t m, size_t n)
 	return memset(p, 0, n);
 }
 
-void *realloc(void *p, size_t n)
+void *libc_realloc(void *p, size_t n)
 {
 	struct chunk *self, *next;
 	size_t n0, n1;
@@ -516,7 +517,7 @@ static void unmap_chunk(struct chunk *self)
 	__munmap(base, len);
 }
 
-void free(void *p)
+void libc_free(void *p)
 {
 	if (!p) return;
 
@@ -546,3 +547,21 @@ void __malloc_donate(char *start, char *end)
 	c->csize = n->psize = C_INUSE | (end-start);
 	__bin_chunk(c);
 }
+
+__attribute__((__weak__))
+void free(void *p)
+{
+    return libc_free(p);
+}
+
+__attribute__((__weak__))
+void *malloc(size_t n)
+{
+    return libc_malloc(n);
+}
+
+__attribute__((__weak__))
+void *realloc(void *p, size_t n)
+{
+    return libc_realloc(p, n);
+}
diff --git a/src/malloc/malloc_usable_size.c b/src/malloc/malloc_usable_size.c
index 672b518a..0f9a8057 100644
--- a/src/malloc/malloc_usable_size.c
+++ b/src/malloc/malloc_usable_size.c
@@ -3,7 +3,13 @@
  
 hidden void *(*const __realloc_dep)(void *, size_t) = realloc;
 
-size_t malloc_usable_size(void *p)
+size_t libc_malloc_usable_size(void *p)
 {
 	return p ? CHUNK_SIZE(MEM_TO_CHUNK(p)) - OVERHEAD : 0;
 }
+
+__attribute__((__weak__))
+size_t malloc_usable_size(void *p)
+{
+    return libc_malloc_usable_size(p);
+}
diff --git a/src/malloc/memalign.c b/src/malloc/memalign.c
index cf9dfbda..ac1fca21 100644
--- a/src/malloc/memalign.c
+++ b/src/malloc/memalign.c
@@ -3,7 +3,9 @@
 #include <errno.h>
 #include "malloc_impl.h"
 
-void *__memalign(size_t align, size_t len)
+void *libc_malloc(size_t n);
+
+void *libc_memalign(size_t align, size_t len)
 {
 	unsigned char *mem, *new;
 
@@ -18,9 +20,9 @@ void *__memalign(size_t align, size_t len)
 	}
 
 	if (align <= SIZE_ALIGN)
-		return malloc(len);
+		return libc_malloc(len);
 
-	if (!(mem = malloc(len + align-1)))
+	if (!(mem = libc_malloc(len + align-1)))
 		return 0;
 
 	new = (void *)((uintptr_t)mem + align-1 & -align);
@@ -51,4 +53,14 @@ void *__memalign(size_t align, size_t len)
 	return new;
 }
 
-weak_alias(__memalign, memalign);
+__attribute__((__weak__))
+void *__memalign(size_t align, size_t len)
+{
+    return libc_memalign(align, len);
+}
+
+__attribute__((__weak__))
+void *memalign(size_t align, size_t len)
+{
+    return libc_memalign(align, len);
+}
diff --git a/src/malloc/posix_memalign.c b/src/malloc/posix_memalign.c
index 2ea8bd8a..dd3d3d97 100644
--- a/src/malloc/posix_memalign.c
+++ b/src/malloc/posix_memalign.c
@@ -2,11 +2,19 @@
 #include <errno.h>
 #include "malloc_impl.h"
 
-int posix_memalign(void **res, size_t align, size_t len)
+void *libc_memalign(size_t alignment, size_t size);
+
+int libc_posix_memalign(void **res, size_t align, size_t len)
 {
 	if (align < sizeof(void *)) return EINVAL;
-	void *mem = __memalign(align, len);
+	void *mem = libc_memalign(align, len);
 	if (!mem) return errno;
 	*res = mem;
 	return 0;
 }
+
+__attribute__((__weak__))
+int posix_memalign(void **res, size_t align, size_t len)
+{
+    return libc_posix_memalign(res, align, len);
+}
diff --git a/src/math/frexp.c b/src/math/frexp.c
index 27b6266e..fb5d51be 100644
--- a/src/math/frexp.c
+++ b/src/math/frexp.c
@@ -5,6 +5,7 @@ double frexp(double x, int *e)
 {
 	union { double d; uint64_t i; } y = { x };
 	int ee = y.i>>52 & 0x7ff;
+	*e = 0;
 
 	if (!ee) {
 		if (x) {
diff --git a/src/math/frexpf.c b/src/math/frexpf.c
index 07870975..a4299705 100644
--- a/src/math/frexpf.c
+++ b/src/math/frexpf.c
@@ -5,6 +5,7 @@ float frexpf(float x, int *e)
 {
 	union { float f; uint32_t i; } y = { x };
 	int ee = y.i>>23 & 0xff;
+	*e = 0;
 
 	if (!ee) {
 		if (x) {
diff --git a/src/math/frexpl.c b/src/math/frexpl.c
index 3c1b5537..a72f05b7 100644
--- a/src/math/frexpl.c
+++ b/src/math/frexpl.c
@@ -10,6 +10,7 @@ long double frexpl(long double x, int *e)
 {
 	union ldshape u = {x};
 	int ee = u.i.se & 0x7fff;
+	*e = 0;
 
 	if (!ee) {
 		if (x) {
diff --git a/src/math/jnf.c b/src/math/jnf.c
index f63c062f..50311758 100644
--- a/src/math/jnf.c
+++ b/src/math/jnf.c
@@ -200,3 +200,13 @@ float ynf(int n, float x)
 	}
 	return sign ? -b : b;
 }
+
+double jnl (int n, double x)
+{
+	return (double)jnf(n, x);
+}
+
+double ynl (int n, double x)
+{
+	return (double)yn(n, x);
+}
diff --git a/src/misc/ioctl.c b/src/misc/ioctl.c
index 89477511..bff57fbc 100644
--- a/src/misc/ioctl.c
+++ b/src/misc/ioctl.c
@@ -112,7 +112,7 @@ static void convert_ioctl_struct(const struct ioctl_compat_map *map, char *old,
 	else memcpy(new+new_offset, old+old_offset, old_size-old_offset);
 }
 
-int ioctl(int fd, int req, ...)
+int ioctl(int fd, unsigned long req, ...)
 {
 	void *arg;
 	va_list ap;
diff --git a/src/misc/syscall.c b/src/misc/syscall.c
index 6f3ef656..614121c3 100644
--- a/src/misc/syscall.c
+++ b/src/misc/syscall.c
@@ -2,6 +2,7 @@
 #include <unistd.h>
 #include "syscall.h"
 #include <stdarg.h>
+#include <errno.h>
 
 #undef syscall
 
@@ -19,3 +20,28 @@ long syscall(long n, ...)
 	va_end(ap);
 	return __syscall_ret(__syscall(n,a,b,c,d,e,f));
 }
+
+__attribute__((__weak__))
+long myst_syscall(long n, long params[6])
+{
+    (void)n;
+    (void)params;
+    return EINVAL;
+}
+
+long myst_syscall_variadic(long n, ...)
+{
+    va_list ap;
+    long params[6];
+
+    va_start(ap, n);
+    params[0] = va_arg(ap, long);
+    params[1] = va_arg(ap, long);
+    params[2] = va_arg(ap, long);
+    params[3] = va_arg(ap, long);
+    params[4] = va_arg(ap, long);
+    params[5] = va_arg(ap, long);
+    va_end(ap);
+
+    return myst_syscall(n, params);
+}
diff --git a/src/multibyte/wcsnrtombs.c b/src/multibyte/wcsnrtombs.c
index 676932b5..6e513741 100644
--- a/src/multibyte/wcsnrtombs.c
+++ b/src/multibyte/wcsnrtombs.c
@@ -2,6 +2,7 @@
 
 size_t wcsnrtombs(char *restrict dst, const wchar_t **restrict wcs, size_t wn, size_t n, mbstate_t *restrict st)
 {
+#ifdef MYST_ENABLE_WCSNRTOMBS
 	size_t l, cnt=0, n2;
 	char *s, buf[256];
 	const wchar_t *ws = *wcs;
@@ -40,4 +41,14 @@ size_t wcsnrtombs(char *restrict dst, const wchar_t **restrict wcs, size_t wn, s
 	}
 	if (dst) *wcs = ws;
 	return cnt;
+#else
+    /* Temporarily disable the insecure wcsnrtombs, which
+     * will be patched in MUSL 1.2.2. */
+    (void)dst;
+    (void)wcs;
+    (void)wn;
+    (void)n;
+    (void)st;
+    return 0;
+#endif
 }
diff --git a/src/network/h_errno.c b/src/network/h_errno.c
index 4f700cea..4306ade2 100644
--- a/src/network/h_errno.c
+++ b/src/network/h_errno.c
@@ -1,9 +1,9 @@
 #include <netdb.h>
 
-#undef h_errno
-int h_errno;
-
+#undef __h_errno
+int __h_errno;
+ 
 int *__h_errno_location(void)
 {
-	return &h_errno;
-}
+	return &__h_errno;
+}
\ No newline at end of file
diff --git a/src/network/res_init.c b/src/network/res_init.c
index 5dba9dfc..9b595a19 100644
--- a/src/network/res_init.c
+++ b/src/network/res_init.c
@@ -4,3 +4,5 @@ int res_init()
 {
 	return 0;
 }
+
+weak_alias(res_init, __res_init);
\ No newline at end of file
diff --git a/src/network/sendmmsg.c b/src/network/sendmmsg.c
index eeae1d0a..7e13faa8 100644
--- a/src/network/sendmmsg.c
+++ b/src/network/sendmmsg.c
@@ -28,3 +28,4 @@ error:
 	return syscall_cp(SYS_sendmmsg, fd, msgvec, vlen, flags);
 #endif
 }
+weak_alias (sendmmsg, __sendmmsg);
diff --git a/src/process/fork.c b/src/process/fork.c
index fb42478a..2d0921f8 100644
--- a/src/process/fork.c
+++ b/src/process/fork.c
@@ -22,15 +22,28 @@ pid_t fork(void)
 #else
 	ret = __syscall(SYS_clone, SIGCHLD, 0);
 #endif
-	if (!ret) {
+
+        if (!ret) {
 		pthread_t self = __pthread_self();
 		self->tid = __syscall(SYS_gettid);
 		self->robust_list.off = 0;
 		self->robust_list.pending = 0;
 		self->next = self->prev = self;
+
+		// In Linux, the child process can safely modify the libc internal variables as below
+		// since (v)fork creates a new memory space for the child; any changes done by the child
+		// does not affect the parent.
+		// However, in mystikos, after (v)fork, the child still shares the same libc/crt as the parent.
+		// Therefore, it is not safe to modify the libc state. It is only after execve that the child
+		// gets its own crt/libc.
+		// Some LTP tests (e.g /ltp/testcases/kernel/syscalls/fchmod/fchmod05) rely on fork.
+		// Those tests rely on the tid for the thread being set above.
+#if 0
 		__thread_list_lock = 0;
 		libc.threads_minus_1 = 0;
-	}
+#endif
+       }
+
 	__restore_sigs(&set);
 	__fork_handler(!ret);
 	return __syscall_ret(ret);
diff --git a/src/process/x86_64/vfork.s b/src/process/x86_64/vfork.s
index 91144390..809463a1 100644
--- a/src/process/x86_64/vfork.s
+++ b/src/process/x86_64/vfork.s
@@ -1,4 +1,5 @@
 .global vfork
+.weak vfork
 .type vfork,@function
 vfork:
 	pop %rdx
diff --git a/src/sched/affinity.c b/src/sched/affinity.c
index 948ece41..fd7e7801 100644
--- a/src/sched/affinity.c
+++ b/src/sched/affinity.c
@@ -31,3 +31,49 @@ int pthread_getaffinity_np(pthread_t td, size_t size, cpu_set_t *set)
 {
 	return -do_getaffinity(td->tid, size, set);
 }
+
+int pthread_attr_setaffinity_np(pthread_attr_t *a,
+         size_t cpusetsize, const cpu_set_t *cpuset)
+{
+	if ((!cpuset) || (cpusetsize==0)) 
+	{
+		if(a->_a_cpuset) free((void*)(a->_a_cpuset));
+		a->_a_cpuset = 0;
+		a->_a_cpusetsize = 0;
+	}
+	else
+	{
+		if(cpusetsize > a->_a_cpusetsize)
+		{
+			void* attr_cpuset;
+			if(!a->_a_cpuset)
+				attr_cpuset = malloc(cpusetsize);
+			else 
+				attr_cpuset = realloc((void*)(a->_a_cpuset), cpusetsize);
+			if (!attr_cpuset)
+				return ENOMEM;
+			else
+				a->_a_cpuset = (unsigned long)attr_cpuset;
+		}
+		memcpy((void*)(a->_a_cpuset), cpuset, cpusetsize);
+		a->_a_cpusetsize = cpusetsize;
+	}
+	return 0;
+}
+
+int pthread_attr_getaffinity_np(pthread_attr_t *a,
+         size_t cpusetsize, cpu_set_t *cpuset)
+{
+	if ((!cpuset) || (cpusetsize==0)) 
+	{
+		return EINVAL;
+	}
+	else if (cpusetsize < a->_a_cpusetsize)
+	{
+		return EINVAL;
+	}
+	memset(cpuset, 0, cpusetsize);
+	if (a->_a_cpuset)
+		memcpy(cpuset, (void*)a->_a_cpuset, a->_a_cpusetsize );
+	return 0;
+}
\ No newline at end of file
diff --git a/src/sched/sched_getparam.c b/src/sched/sched_getparam.c
index 76f10e49..c055a47f 100644
--- a/src/sched/sched_getparam.c
+++ b/src/sched/sched_getparam.c
@@ -2,7 +2,9 @@
 #include <errno.h>
 #include "syscall.h"
 
-int sched_getparam(pid_t pid, struct sched_param *param)
+int do_sched_getparam(pid_t pid, struct sched_param *param)
 {
 	return __syscall_ret(-ENOSYS);
 }
+
+_Noreturn weak_alias(do_sched_getparam, sched_getparam);
diff --git a/src/select/poll.c b/src/select/poll.c
index c84c8a99..a5f561bd 100644
--- a/src/select/poll.c
+++ b/src/select/poll.c
@@ -13,3 +13,4 @@ int poll(struct pollfd *fds, nfds_t n, int timeout)
 		.tv_nsec = timeout%1000*1000000 }) : 0, 0, _NSIG/8);
 #endif
 }
+weak_alias (poll, __poll);
diff --git a/src/signal/sigprocmask.c b/src/signal/sigprocmask.c
index 297e20c6..fb1ea903 100644
--- a/src/signal/sigprocmask.c
+++ b/src/signal/sigprocmask.c
@@ -8,3 +8,42 @@ int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict old)
 	errno = r;
 	return -1;
 }
+
+static unsigned int sigset_to_int(const sigset_t *set)
+{
+  unsigned int ret = 0;
+  if (sizeof(sigset_t) == sizeof(ret))
+    return *(unsigned int*)set;
+
+  for (unsigned sig = 1; sig < _NSIG && sig <= sizeof(ret) * 8; sig++) {
+    if (sigismember (set, sig))
+      ret |= (1u << ((sig) - 1));
+  }
+  return ret;
+}
+
+static void int_to_sigset(sigset_t *set, int sigs)
+{
+  if (sizeof(sigset_t) == sizeof(sigs))
+    *(unsigned*)set = sigs;
+
+  sigemptyset(set);
+  for (unsigned sig = 1; sig < _NSIG && sig <= sizeof(sigs) * 8; sig++) {
+    if (sigs & (1u << ((sig) - 1)))
+      sigaddset(set, sig);
+  }
+}
+
+int __sigsetmask (int mask)
+{
+  sigset_t set, old;
+  
+  int_to_sigset(&set, mask);
+
+  if (sigprocmask (SIG_SETMASK, &set, &old) < 0)
+    return -1;
+
+  return sigset_to_int(&old);
+}
+
+weak_alias (__sigsetmask, sigsetmask);
diff --git a/src/stdio/snprintf.c b/src/stdio/snprintf.c
index 771503b2..8a8529b1 100644
--- a/src/stdio/snprintf.c
+++ b/src/stdio/snprintf.c
@@ -10,4 +10,4 @@ int snprintf(char *restrict s, size_t n, const char *restrict fmt, ...)
 	va_end(ap);
 	return ret;
 }
-
+weak_alias (snprintf, __snprintf);
diff --git a/src/string/explicit_bzero.c b/src/string/explicit_bzero.c
index f2e12f23..03f0cd4f 100644
--- a/src/string/explicit_bzero.c
+++ b/src/string/explicit_bzero.c
@@ -1,4 +1,5 @@
 #define _BSD_SOURCE
+#include <stdlib.h>
 #include <string.h>
 
 void explicit_bzero(void *d, size_t n)
@@ -6,3 +7,11 @@ void explicit_bzero(void *d, size_t n)
 	d = memset(d, 0, n);
 	__asm__ __volatile__ ("" : : "r"(d) : "memory");
 }
+
+void __explicit_bzero_chk(void *d, size_t len, size_t dlen)
+{
+	if (dlen < len)
+		abort();
+	d = memset(d, 0, len);
+	__asm__ __volatile__("" : : "r"(d) : "memory");
+}
\ No newline at end of file
diff --git a/src/thread/__unmapself.c b/src/thread/__unmapself.c
index 31d94e67..f57fdf0c 100644
--- a/src/thread/__unmapself.c
+++ b/src/thread/__unmapself.c
@@ -1,24 +1,9 @@
-#include "pthread_impl.h"
-#include "atomic.h"
+#include <stddef.h>
 #include "syscall.h"
-/* cheat and reuse CRTJMP macro from dynlink code */
-#include "dynlink.h"
-
-static void *unmap_base;
-static size_t unmap_size;
-static char shared_stack[256];
-
-static void do_unmap()
-{
-	__syscall(SYS_munmap, unmap_base, unmap_size);
-	__syscall(SYS_exit);
-}
 
 void __unmapself(void *base, size_t size)
 {
-	char *stack = shared_stack + sizeof shared_stack;
-	stack -= (uintptr_t)stack % 16;
-	unmap_base = base;
-	unmap_size = size;
-	CRTJMP(do_unmap, stack);
+        const long SYS_myst_unmap_on_exit = 2013;
+        __syscall2(SYS_myst_unmap_on_exit, base, size);
+        __syscall0(SYS_exit);
 }
diff --git a/src/thread/clone.c b/src/thread/clone.c
index be80c8ea..afc8d160 100644
--- a/src/thread/clone.c
+++ b/src/thread/clone.c
@@ -1,6 +1,7 @@
 #include <errno.h>
 #include "pthread_impl.h"
 
+weak
 int __clone(int (*func)(void *), void *stack, int flags, void *arg, ...)
 {
 	return -ENOSYS;
diff --git a/src/thread/mtx_init.c b/src/thread/mtx_init.c
index 4826f76b..b0d02ec4 100644
--- a/src/thread/mtx_init.c
+++ b/src/thread/mtx_init.c
@@ -3,8 +3,12 @@
 
 int mtx_init(mtx_t *m, int type)
 {
-	*m = (mtx_t){
-		._m_type = ((type&mtx_recursive) ? PTHREAD_MUTEX_RECURSIVE : PTHREAD_MUTEX_NORMAL),
-	};
+	*m = (mtx_t){0};
+
+        if ((type & mtx_recursive))
+            _m_set_type((pthread_mutex_t*)m, PTHREAD_MUTEX_RECURSIVE);
+        else
+            _m_set_type((pthread_mutex_t*)m, PTHREAD_MUTEX_NORMAL);
+
 	return thrd_success;
 }
diff --git a/src/thread/mtx_lock.c b/src/thread/mtx_lock.c
index 5c2415c1..823994fc 100644
--- a/src/thread/mtx_lock.c
+++ b/src/thread/mtx_lock.c
@@ -3,7 +3,7 @@
 
 int mtx_lock(mtx_t *m)
 {
-	if (m->_m_type == PTHREAD_MUTEX_NORMAL && !a_cas(&m->_m_lock, 0, EBUSY))
+	if (_m_get_type((pthread_mutex_t*)m) == PTHREAD_MUTEX_NORMAL && !a_cas(&m->_m_lock, 0, EBUSY))
 		return thrd_success;
 	/* Calling mtx_timedlock with a null pointer is an extension.
 	 * It is convenient, here to avoid duplication of the logic
diff --git a/src/thread/mtx_trylock.c b/src/thread/mtx_trylock.c
index 40a8b8c2..e57d1183 100644
--- a/src/thread/mtx_trylock.c
+++ b/src/thread/mtx_trylock.c
@@ -3,7 +3,7 @@
 
 int mtx_trylock(mtx_t *m)
 {
-	if (m->_m_type == PTHREAD_MUTEX_NORMAL)
+	if (_m_get_type((pthread_mutex_t*)m) == PTHREAD_MUTEX_NORMAL)
 		return (a_cas(&m->_m_lock, 0, EBUSY) & EBUSY) ? thrd_busy : thrd_success;
 
 	int ret = __pthread_mutex_trylock((pthread_mutex_t *)m);
diff --git a/src/thread/pthread_attr_destroy.c b/src/thread/pthread_attr_destroy.c
index b5845dd0..016dcfdd 100644
--- a/src/thread/pthread_attr_destroy.c
+++ b/src/thread/pthread_attr_destroy.c
@@ -2,5 +2,6 @@
 
 int pthread_attr_destroy(pthread_attr_t *a)
 {
+	if(a->_a_cpuset) free((void*)(a->_a_cpuset));
 	return 0;
-}
+}
\ No newline at end of file
diff --git a/src/thread/pthread_attr_setstack.c b/src/thread/pthread_attr_setstack.c
index 1eddcbd6..d3ec0363 100644
--- a/src/thread/pthread_attr_setstack.c
+++ b/src/thread/pthread_attr_setstack.c
@@ -7,3 +7,8 @@ int pthread_attr_setstack(pthread_attr_t *a, void *addr, size_t size)
 	a->_a_stacksize = size;
 	return 0;
 }
+
+size_t __pthread_get_minstack(const pthread_attr_t *attr)
+{
+	return DEFAULT_STACK_SIZE;
+}
diff --git a/src/thread/pthread_cancel.c b/src/thread/pthread_cancel.c
index 2f9d5e97..e4d3d000 100644
--- a/src/thread/pthread_cancel.c
+++ b/src/thread/pthread_cancel.c
@@ -14,9 +14,7 @@ long __cancel()
 	return -ECANCELED;
 }
 
-long __syscall_cp_asm(volatile void *, syscall_arg_t,
-                      syscall_arg_t, syscall_arg_t, syscall_arg_t,
-                      syscall_arg_t, syscall_arg_t, syscall_arg_t);
+long __syscall_cp_asm(volatile void* cancel, long n, long params[6]);
 
 long __syscall_cp_c(syscall_arg_t nr,
                     syscall_arg_t u, syscall_arg_t v, syscall_arg_t w,
@@ -30,7 +28,8 @@ long __syscall_cp_c(syscall_arg_t nr,
 	    && (st==PTHREAD_CANCEL_DISABLE || nr==SYS_close))
 		return __syscall(nr, u, v, w, x, y, z);
 
-	r = __syscall_cp_asm(&self->cancel, nr, u, v, w, x, y, z);
+        long params[6] = { u, v, w, x, y, z };
+	r = __syscall_cp_asm(&self->cancel, nr, params);
 	if (r==-EINTR && nr!=SYS_close && self->cancel &&
 	    self->canceldisable != PTHREAD_CANCEL_DISABLE)
 		r = __cancel();
@@ -56,7 +55,7 @@ static void cancel_handler(int sig, siginfo_t *si, void *ctx)
 
 	_sigaddset(&uc->uc_sigmask, SIGCANCEL);
 
-	if (self->cancelasync || pc >= (uintptr_t)__cp_begin && pc < (uintptr_t)__cp_end) {
+	if (pc >= (uintptr_t)__cp_begin && pc < (uintptr_t)__cp_end) {
 		uc->uc_mcontext.MC_PC = (uintptr_t)__cp_cancel;
 #ifdef CANCEL_GOT
 		uc->uc_mcontext.MC_GOT = CANCEL_GOT;
@@ -64,6 +63,7 @@ static void cancel_handler(int sig, siginfo_t *si, void *ctx)
 		return;
 	}
 
+	__cancel();
 	__syscall(SYS_tkill, self->tid, SIGCANCEL);
 }
 
diff --git a/src/thread/pthread_cond_timedwait.c b/src/thread/pthread_cond_timedwait.c
index d1501240..0b0a919d 100644
--- a/src/thread/pthread_cond_timedwait.c
+++ b/src/thread/pthread_cond_timedwait.c
@@ -65,7 +65,7 @@ int __pthread_cond_timedwait(pthread_cond_t *restrict c, pthread_mutex_t *restri
 	int e, seq, clock = c->_c_clock, cs, shared=0, oldstate, tmp;
 	volatile int *fut;
 
-	if ((m->_m_type&15) && (m->_m_lock&INT_MAX) != __pthread_self()->tid)
+	if ((_m_get_type(m)&15) && (m->_m_lock&INT_MAX) != __pthread_self()->tid)
 		return EPERM;
 
 	if (ts && ts->tv_nsec >= 1000000000UL)
@@ -151,7 +151,7 @@ relock:
 	/* Unlock the barrier that's holding back the next waiter, and
 	 * either wake it or requeue it to the mutex. */
 	if (node.prev)
-		unlock_requeue(&node.prev->barrier, &m->_m_lock, m->_m_type & 128);
+		unlock_requeue(&node.prev->barrier, &m->_m_lock, _m_get_type(m) & 128);
 	else
 		a_dec(&m->_m_waiters);
 
diff --git a/src/thread/pthread_create.c b/src/thread/pthread_create.c
index 5f491092..51c9fafb 100644
--- a/src/thread/pthread_create.c
+++ b/src/thread/pthread_create.c
@@ -108,7 +108,7 @@ _Noreturn void __pthread_exit(void *result)
 		pthread_mutex_t *m = (void *)((char *)rp
 			- offsetof(pthread_mutex_t, _m_next));
 		int waiters = m->_m_waiters;
-		int priv = (m->_m_type & 128) ^ 128;
+		int priv = (_m_get_type(m) & 128) ^ 128;
 		self->robust_list.pending = rp;
 		self->robust_list.head = *rp;
 		int cont = a_swap(&m->_m_lock, 0x40000000);
@@ -345,13 +345,21 @@ int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict att
 	 * clean up all transient resource usage before returning. */
 	if (ret < 0) {
 		ret = -EAGAIN;
-	} else if (attr._a_sched) {
-		ret = __syscall(SYS_sched_setscheduler,
-			new->tid, attr._a_policy, &attr._a_prio);
-		if (a_swap(&args->control, ret ? 3 : 0)==2)
-			__wake(&args->control, 1, 1);
-		if (ret)
-			__wait(&args->control, 0, 3, 0);
+	}
+	else {
+		if (attr._a_cpuset)
+		{
+			ret = __syscall(SYS_sched_setaffinity,
+				new->tid, attr._a_cpusetsize, attr._a_cpuset);
+		}
+		if ((ret>=0) && (attr._a_sched)) {
+			ret = __syscall(SYS_sched_setscheduler,
+				new->tid, attr._a_policy, &attr._a_prio);
+			if (a_swap(&args->control, ret ? 3 : 0)==2)
+				__wake(&args->control, 1, 1);
+			if (ret)
+				__wait(&args->control, 0, 3, 0);
+		}
 	}
 
 	if (ret >= 0) {
diff --git a/src/thread/pthread_getattr_np.c b/src/thread/pthread_getattr_np.c
index 2881831f..26167cf7 100644
--- a/src/thread/pthread_getattr_np.c
+++ b/src/thread/pthread_getattr_np.c
@@ -3,6 +3,7 @@
 #include "libc.h"
 #include <sys/mman.h>
 
+__attribute__((__weak__))
 int pthread_getattr_np(pthread_t t, pthread_attr_t *a)
 {
 	*a = (pthread_attr_t){0};
diff --git a/src/thread/pthread_mutex_consistent.c b/src/thread/pthread_mutex_consistent.c
index 27c74e5b..efadeec8 100644
--- a/src/thread/pthread_mutex_consistent.c
+++ b/src/thread/pthread_mutex_consistent.c
@@ -5,7 +5,7 @@ int pthread_mutex_consistent(pthread_mutex_t *m)
 {
 	int old = m->_m_lock;
 	int own = old & 0x3fffffff;
-	if (!(m->_m_type & 4) || !own || !(old & 0x40000000))
+	if (!(_m_get_type(m) & 4) || !own || !(old & 0x40000000))
 		return EINVAL;
 	if (own != __pthread_self()->tid)
 		return EPERM;
diff --git a/src/thread/pthread_mutex_init.c b/src/thread/pthread_mutex_init.c
index acf45a74..05108e52 100644
--- a/src/thread/pthread_mutex_init.c
+++ b/src/thread/pthread_mutex_init.c
@@ -3,6 +3,6 @@
 int pthread_mutex_init(pthread_mutex_t *restrict m, const pthread_mutexattr_t *restrict a)
 {
 	*m = (pthread_mutex_t){0};
-	if (a) m->_m_type = a->__attr;
+	if (a) _m_set_type(m, a->__attr);
 	return 0;
 }
diff --git a/src/thread/pthread_mutex_lock.c b/src/thread/pthread_mutex_lock.c
index 638d4b86..6562793a 100644
--- a/src/thread/pthread_mutex_lock.c
+++ b/src/thread/pthread_mutex_lock.c
@@ -2,7 +2,7 @@
 
 int __pthread_mutex_lock(pthread_mutex_t *m)
 {
-	if ((m->_m_type&15) == PTHREAD_MUTEX_NORMAL
+	if ((_m_get_type(m)&15) == PTHREAD_MUTEX_NORMAL
 	    && !a_cas(&m->_m_lock, 0, EBUSY))
 		return 0;
 
diff --git a/src/thread/pthread_mutex_timedlock.c b/src/thread/pthread_mutex_timedlock.c
index 9279fc54..243cb6c7 100644
--- a/src/thread/pthread_mutex_timedlock.c
+++ b/src/thread/pthread_mutex_timedlock.c
@@ -20,7 +20,7 @@ static int __futex4(volatile void *addr, int op, int val, const struct timespec
 
 static int pthread_mutex_timedlock_pi(pthread_mutex_t *restrict m, const struct timespec *restrict at)
 {
-	int type = m->_m_type;
+	int type = _m_get_type(m);
 	int priv = (type & 128) ^ 128;
 	pthread_t self = __pthread_self();
 	int e;
@@ -55,11 +55,11 @@ static int pthread_mutex_timedlock_pi(pthread_mutex_t *restrict m, const struct
 
 int __pthread_mutex_timedlock(pthread_mutex_t *restrict m, const struct timespec *restrict at)
 {
-	if ((m->_m_type&15) == PTHREAD_MUTEX_NORMAL
+	if ((_m_get_type(m)&15) == PTHREAD_MUTEX_NORMAL
 	    && !a_cas(&m->_m_lock, 0, EBUSY))
 		return 0;
 
-	int type = m->_m_type;
+	int type = _m_get_type(m);
 	int r, t, priv = (type & 128) ^ 128;
 
 	r = __pthread_mutex_trylock(m);
diff --git a/src/thread/pthread_mutex_trylock.c b/src/thread/pthread_mutex_trylock.c
index a24e7c58..9bac7411 100644
--- a/src/thread/pthread_mutex_trylock.c
+++ b/src/thread/pthread_mutex_trylock.c
@@ -3,7 +3,7 @@
 int __pthread_mutex_trylock_owner(pthread_mutex_t *m)
 {
 	int old, own;
-	int type = m->_m_type;
+	int type = _m_get_type(m);
 	pthread_t self = __pthread_self();
 	int tid = self->tid;
 
@@ -66,7 +66,7 @@ success:
 
 int __pthread_mutex_trylock(pthread_mutex_t *m)
 {
-	if ((m->_m_type&15) == PTHREAD_MUTEX_NORMAL)
+	if ((_m_get_type(m)&15) == PTHREAD_MUTEX_NORMAL)
 		return a_cas(&m->_m_lock, 0, EBUSY) & EBUSY;
 	return __pthread_mutex_trylock_owner(m);
 }
diff --git a/src/thread/pthread_mutex_unlock.c b/src/thread/pthread_mutex_unlock.c
index b66423e6..d9dfd608 100644
--- a/src/thread/pthread_mutex_unlock.c
+++ b/src/thread/pthread_mutex_unlock.c
@@ -5,8 +5,8 @@ int __pthread_mutex_unlock(pthread_mutex_t *m)
 	pthread_t self;
 	int waiters = m->_m_waiters;
 	int cont;
-	int type = m->_m_type & 15;
-	int priv = (m->_m_type & 128) ^ 128;
+	int type = _m_get_type(m) & 15;
+	int priv = (_m_get_type(m) & 128) ^ 128;
 	int new = 0;
 	int old;
 
diff --git a/src/thread/sem_timedwait.c b/src/thread/sem_timedwait.c
index 58d3ebfe..002736e1 100644
--- a/src/thread/sem_timedwait.c
+++ b/src/thread/sem_timedwait.c
@@ -6,7 +6,7 @@ static void cleanup(void *p)
 	a_dec(p);
 }
 
-int sem_timedwait(sem_t *restrict sem, const struct timespec *restrict at)
+int sem_clockwait(sem_t *restrict sem, clockid_t clockid, const struct timespec *restrict at)
 {
 	pthread_testcancel();
 
@@ -20,7 +20,7 @@ int sem_timedwait(sem_t *restrict sem, const struct timespec *restrict at)
 		a_inc(sem->__val+1);
 		a_cas(sem->__val, 0, -1);
 		pthread_cleanup_push(cleanup, (void *)(sem->__val+1));
-		r = __timedwait_cp(sem->__val, -1, CLOCK_REALTIME, at, sem->__val[2]);
+		r = __timedwait_cp(sem->__val, -1, clockid, at, sem->__val[2]);
 		pthread_cleanup_pop(1);
 		if (r) {
 			errno = r;
@@ -29,3 +29,8 @@ int sem_timedwait(sem_t *restrict sem, const struct timespec *restrict at)
 	}
 	return 0;
 }
+
+int sem_timedwait(sem_t *restrict sem, const struct timespec *restrict at)
+{
+	return sem_clockwait(sem, CLOCK_REALTIME, at);
+}
diff --git a/src/thread/x86_64/__set_thread_area.s b/src/thread/x86_64/__set_thread_area.s
deleted file mode 100644
index 7347ff4d..00000000
--- a/src/thread/x86_64/__set_thread_area.s
+++ /dev/null
@@ -1,11 +0,0 @@
-/* Copyright 2011-2012 Nicholas J. Kain, licensed under standard MIT license */
-.text
-.global __set_thread_area
-.hidden __set_thread_area
-.type __set_thread_area,@function
-__set_thread_area:
-	mov %rdi,%rsi           /* shift for syscall */
-	movl $0x1002,%edi       /* SET_FS register */
-	movl $158,%eax          /* set fs segment to */
-	syscall                 /* arch_prctl(SET_FS, arg)*/
-	ret
diff --git a/src/thread/x86_64/__unmapself.s b/src/thread/x86_64/__unmapself.s
deleted file mode 100644
index e2689e65..00000000
--- a/src/thread/x86_64/__unmapself.s
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Copyright 2011-2012 Nicholas J. Kain, licensed under standard MIT license */
-.text
-.global __unmapself
-.type   __unmapself,@function
-__unmapself:
-	movl $11,%eax   /* SYS_munmap */
-	syscall         /* munmap(arg2,arg3) */
-	xor %rdi,%rdi   /* exit() args: always return success */
-	movl $60,%eax   /* SYS_exit */
-	syscall         /* exit(0) */
diff --git a/src/thread/x86_64/clone.s b/src/thread/x86_64/clone.s
deleted file mode 100644
index 6e47bc0a..00000000
--- a/src/thread/x86_64/clone.s
+++ /dev/null
@@ -1,28 +0,0 @@
-.text
-.global __clone
-.hidden __clone
-.type   __clone,@function
-__clone:
-	xor %eax,%eax
-	mov $56,%al
-	mov %rdi,%r11
-	mov %rdx,%rdi
-	mov %r8,%rdx
-	mov %r9,%r8
-	mov 8(%rsp),%r10
-	mov %r11,%r9
-	and $-16,%rsi
-	sub $8,%rsi
-	mov %rcx,(%rsi)
-	syscall
-	test %eax,%eax
-	jnz 1f
-	xor %ebp,%ebp
-	pop %rdi
-	call *%r9
-	mov %eax,%edi
-	xor %eax,%eax
-	mov $60,%al
-	syscall
-	hlt
-1:	ret
diff --git a/src/thread/x86_64/syscall_cp.s b/src/thread/x86_64/syscall_cp.s
index 4f101716..c6091da5 100644
--- a/src/thread/x86_64/syscall_cp.s
+++ b/src/thread/x86_64/syscall_cp.s
@@ -9,22 +9,19 @@
 .global __syscall_cp_asm
 .hidden __syscall_cp_asm
 .type   __syscall_cp_asm,@function
+// __syscall_cp_asm(%rdi=cancel, %rsi=n, %rdx=params)
 __syscall_cp_asm:
 
 __cp_begin:
 	mov (%rdi),%eax
 	test %eax,%eax
 	jnz __cp_cancel
+
 	mov %rdi,%r11
-	mov %rsi,%rax
-	mov %rdx,%rdi
-	mov %rcx,%rsi
-	mov %r8,%rdx
-	mov %r9,%r10
-	mov 8(%rsp),%r8
-	mov 16(%rsp),%r9
+        mov %rsi, %rdi
+        mov %rdx, %rsi
 	mov %r11,8(%rsp)
-	syscall
+	jmp myst_syscall
 __cp_end:
 	ret
 __cp_cancel:
diff --git a/src/unistd/close.c b/src/unistd/close.c
index 5b38e019..e80418e6 100644
--- a/src/unistd/close.c
+++ b/src/unistd/close.c
@@ -16,3 +16,4 @@ int close(int fd)
 	if (r == -EINTR) r = 0;
 	return __syscall_ret(r);
 }
+weak_alias(close, __close_nocancel);
diff --git a/src/unistd/read.c b/src/unistd/read.c
index f3589c05..12e46040 100644
--- a/src/unistd/read.c
+++ b/src/unistd/read.c
@@ -5,3 +5,4 @@ ssize_t read(int fd, void *buf, size_t count)
 {
 	return syscall_cp(SYS_read, fd, buf, count);
 }
+weak_alias(read, __read_nocancel);
diff --git a/src/unistd/write.c b/src/unistd/write.c
index 8fd5bc5c..38bfbbd8 100644
--- a/src/unistd/write.c
+++ b/src/unistd/write.c
@@ -5,3 +5,4 @@ ssize_t write(int fd, const void *buf, size_t count)
 {
 	return syscall_cp(SYS_write, fd, buf, count);
 }
+weak_alias(write, __write_nocancel);
diff --git a/src/internal/__popcountdi2.c b/src/internal/__popcountdi2.c
new file mode 100644
index 00000000..b4b374a1
--- /dev/null
+++ b/src/internal/__popcountdi2.c
@@ -0,0 +1,16 @@
+
+__attribute__((__weak__))
+int __popcountdi2(unsigned long a)
+{
+    unsigned long nbits = 0;
+
+    /* Count the number of bits that are set */
+    for (unsigned long i = 0; i < 64; i++)
+    {
+        if ((a & (1LU << i)))
+            nbits++;
+    }
+
+    /* Return 1 if the nbits is odd; return 0 if nbits is event */
+    return (nbits % 2) ? 1 : 0;
+}
diff --git a/src/stdio/__fprintf_chk.c b/src/stdio/__fprintf_chk.c
new file mode 100644
index 00000000..50253c11
--- /dev/null
+++ b/src/stdio/__fprintf_chk.c
@@ -0,0 +1,23 @@
+#include <stdio.h>
+#include <stdarg.h>
+
+extern int __vfprintf_chk(
+    FILE *stream,
+    int flag,
+    const char *format,
+    va_list ap);
+
+__attribute__((__weak__))
+int __fprintf_chk(FILE *stream, int flag, const char *format, ...)
+{
+    int ret;
+    va_list ap;
+
+    (void)flag;
+
+    va_start(ap, format);
+    ret = __vfprintf_chk(stream, flag, format, ap);
+    va_end(ap);
+
+    return ret;
+}
diff --git a/src/stdio/__vfprintf_chk.c b/src/stdio/__vfprintf_chk.c
new file mode 100644
index 00000000..5493e453
--- /dev/null
+++ b/src/stdio/__vfprintf_chk.c
@@ -0,0 +1,11 @@
+#include <stdio.h>
+#include <assert.h>
+
+__attribute__((__weak__))
+int __vfprintf_chk(FILE *stream, int flag, const char *format, va_list ap)
+{
+    assert(stream);
+    assert(format);
+    (void)flag;
+    return vfprintf(stream, format, ap);
+}
diff --git a/src/stdio/register_printf.c b/src/stdio/register_printf.c
new file mode 100644
index 00000000..d2226f33
--- /dev/null
+++ b/src/stdio/register_printf.c
@@ -0,0 +1,196 @@
+#include "stdio_impl.h"
+#include "lock.h"
+#include <errno.h>
+#include <limits.h>
+#include <stdlib.h>
+#include <wchar.h>
+
+#define MAX_VA_ARG_TABLE_SIZE 32
+#define MAX_ARGINFO_TABLE_SIZE 52
+#define MAX_MODIFIER_BIT 32
+#define FIRST_PRINTF_USER_TYPE 8
+
+struct printf_info
+{
+};
+
+struct printf_modifier_record
+{
+    struct printf_modifier_record *next;
+    int bit;
+    wchar_t str[0];
+};
+
+typedef void printf_va_arg_fn(void *mem, va_list *va);
+typedef int printf_arginfo_fn(const struct printf_info *info, size_t n, int *argtypes, int *size);
+typedef int printf_convert_fn(FILE *stream, const struct printf_info *info, const void *const *args);
+
+/* Array of printf_modifier_record lists indexed by the
+   first char of the modifier. */
+static struct printf_modifier_record **_printf_modifier_table = NULL;
+
+/* Array of functions indexed by id.  */
+static printf_va_arg_fn **_printf_va_arg_fn_table = NULL;
+
+/* Array of functions indexed by format character.  */
+static printf_arginfo_fn **_printf_arginfo_fn_table = NULL;
+
+/* Array of functions indexed by format character.  */
+static printf_convert_fn **_printf_convert_fn_table = NULL;
+
+static volatile int lock[1];
+static int _atexit_initialized = 0;
+
+static void _free_printf_tables()
+{
+    free(_printf_va_arg_fn_table);
+    free(_printf_arginfo_fn_table);
+    if (_printf_modifier_table)
+    {
+        for (size_t i=0; i<UCHAR_MAX; i++)
+        {
+            struct printf_modifier_record *tmp = _printf_modifier_table[i];
+            for (; tmp != NULL;)
+            {
+                struct printf_modifier_record *next = tmp->next;
+                free(tmp);
+                tmp = next;
+            }
+        }
+        free(_printf_modifier_table);
+    }
+}
+
+/* Register a printf type with its va_args function */
+int __register_printf_type (printf_va_arg_fn fn)
+{
+    static _Atomic int _next_type = FIRST_PRINTF_USER_TYPE;
+    int result = -1;
+
+    LOCK(lock);
+    if (!_atexit_initialized)
+    {
+        atexit(_free_printf_tables);
+        _atexit_initialized = 1;
+    }
+
+    if (_printf_va_arg_fn_table == NULL)
+    {
+        _printf_va_arg_fn_table = calloc(MAX_VA_ARG_TABLE_SIZE, sizeof(*_printf_va_arg_fn_table));
+        if (_printf_va_arg_fn_table == NULL)
+        {
+            errno = ENOMEM;
+            UNLOCK(lock);
+            return -1;
+        }
+    }
+    UNLOCK(lock);
+
+    if (_next_type == MAX_VA_ARG_TABLE_SIZE + FIRST_PRINTF_USER_TYPE)
+    {
+        errno = ENOSPC;
+        return -1;
+    }
+
+    result = _next_type++;
+    _printf_va_arg_fn_table[result - FIRST_PRINTF_USER_TYPE] = fn;
+
+    return result;
+}
+weak_alias(__register_printf_type, register_printf_type);
+
+/* Register functions to be called to format SPEC specifiers.  */
+int __register_printf_specifier (int spec, printf_convert_fn convert_fn, printf_arginfo_fn arginfo_fn)
+{
+    int index = -1;
+    if (spec >= 'a' && spec <= 'z')
+        index = spec - 'a' + 26;
+    else if (spec >= 'A' && spec <= 'Z')
+        index = spec - 'A';
+    else
+    {
+        errno = EINVAL;
+        return -1;
+    }
+
+    LOCK(lock);
+    if (_printf_arginfo_fn_table == NULL)
+    {
+        _printf_arginfo_fn_table = calloc(MAX_ARGINFO_TABLE_SIZE, sizeof(void*)*2);
+        if (_printf_arginfo_fn_table == NULL)
+        {
+            errno = ENOMEM;
+            goto done;
+        }
+        _printf_convert_fn_table = (printf_convert_fn **)_printf_arginfo_fn_table + MAX_ARGINFO_TABLE_SIZE;
+    }
+    _printf_arginfo_fn_table[index] = arginfo_fn;
+    _printf_convert_fn_table[index] = convert_fn;
+
+done:
+    UNLOCK(lock);
+    return 0;
+}
+weak_alias (__register_printf_specifier, register_printf_specifier);
+
+int __register_printf_modifier (const wchar_t *str)
+{
+    /* Bits to hand out for modifiers.  */
+    static int next_bit = 0;
+
+    if (str[0] == L'\0')
+    {
+        errno = EINVAL;
+        return -1;
+    }
+
+    const wchar_t *wc = str;
+    for (; *wc != L'\0'; ++wc)
+    {
+        if (*wc < 0 || *wc > (wchar_t) UCHAR_MAX)
+        {
+            errno = EINVAL;
+            return -1;
+        }
+    }
+
+    if (next_bit == MAX_MODIFIER_BIT)
+    {
+        errno = ENOSPC;
+        return -1;
+    }
+
+    int result = -1;
+    unsigned char firstchar = (unsigned char)*str;
+    LOCK(lock);
+
+    if (_printf_modifier_table == NULL)
+    {
+        _printf_modifier_table = calloc (UCHAR_MAX, sizeof (*_printf_modifier_table));
+        if (_printf_modifier_table == NULL)
+        {
+            errno = ENOMEM;
+            goto done;
+        }
+    }
+
+    struct printf_modifier_record *newp = malloc (sizeof (*newp) + ((wc - str) * sizeof (wchar_t)));
+    if (newp == NULL)
+    {
+        errno = ENOMEM;
+        goto done;
+    }
+
+    newp->next = _printf_modifier_table[firstchar];
+    newp->bit = 1 << next_bit++;
+    wmemcpy (newp->str, str + 1, wc - str);
+
+    _printf_modifier_table[firstchar] = newp;
+
+    result = newp->bit;
+
+done:
+    UNLOCK(lock);
+    return result;
+}
+weak_alias (__register_printf_modifier, register_printf_modifier);
diff --git a/src/unistd/preadv2.c b/src/unistd/preadv2.c
new file mode 100644
index 00000000..b58c73ab
--- /dev/null
+++ b/src/unistd/preadv2.c
@@ -0,0 +1,16 @@
+#define _BSD_SOURCE
+#include <sys/uio.h>
+#include <unistd.h>
+#include "syscall.h"
+
+ssize_t preadv2(
+        int fd,
+        const struct iovec *iov,
+        int count,
+        off_t offset,
+        int flags)
+{
+	return syscall_cp(SYS_preadv2, fd, iov, count, offset, flags);
+}
+
+weak_alias(preadv2, preadv64v2);
diff --git a/src/unistd/pwritev2.c b/src/unistd/pwritev2.c
new file mode 100644
index 00000000..6612ffd8
--- /dev/null
+++ b/src/unistd/pwritev2.c
@@ -0,0 +1,16 @@
+#define _BSD_SOURCE
+#include <sys/uio.h>
+#include <unistd.h>
+#include "syscall.h"
+
+ssize_t pwritev2(
+        int fd,
+        const struct iovec *iov,
+        int count,
+        off_t offset,
+        int flags)
+{
+	return syscall_cp(SYS_pwritev2, fd, iov, count, offset, flags);
+}
+
+weak_alias(pwritev2, pwritev64v2);
