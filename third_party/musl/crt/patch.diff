diff --git a/Makefile b/Makefile
index bd8f5c38..fcc35f3e 100644
--- a/Makefile
+++ b/Makefile
@@ -160,12 +160,16 @@ obj/%.lo: $(srcdir)/%.c $(GENH) $(IMPH)
 lib/libc.so: $(LOBJS) $(LDSO_OBJS)
 	$(CC) $(CFLAGS_ALL) $(LDFLAGS_ALL) -nostdlib -shared \
 	-Wl,-e,_dlstart -o $@ $(LOBJS) $(LDSO_OBJS) $(LIBCC)
+	$(MAKE) objects.mak
 
 lib/libc.a: $(AOBJS)
 	rm -f $@
 	$(AR) rc $@ $(AOBJS)
 	$(RANLIB) $@
 
+objects.mak: $(LOBJS) $(LDSO_OBJS)
+	@ echo "MUSL_OBJECTS = $(addprefix $(CURDIR)/,$(LOBJS) $(LDSO_OBJS))" > objects.mak
+
 $(EMPTY_LIBS):
 	rm -f $@
 	$(AR) rc $@
diff --git a/arch/x86_64/syscall_arch.h b/arch/x86_64/syscall_arch.h
index 92d5c179..e94deece 100644
--- a/arch/x86_64/syscall_arch.h
+++ b/arch/x86_64/syscall_arch.h
@@ -1,64 +1,69 @@
 #define __SYSCALL_LL_E(x) (x)
 #define __SYSCALL_LL_O(x) (x)
 
+long myst_syscall(long n, long params[6]);
+
 static __inline long __syscall0(long n)
 {
-	unsigned long ret;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n) : "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    return myst_syscall(n, params);
 }
 
 static __inline long __syscall1(long n, long a1)
 {
-	unsigned long ret;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1) : "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    params[0] = a1;
+    return myst_syscall(n, params);
 }
 
 static __inline long __syscall2(long n, long a1, long a2)
 {
-	unsigned long ret;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2)
-						  : "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    params[0] = a1;
+    params[1] = a2;
+    return myst_syscall(n, params);
 }
 
 static __inline long __syscall3(long n, long a1, long a2, long a3)
 {
-	unsigned long ret;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
-						  "d"(a3) : "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    params[0] = a1;
+    params[1] = a2;
+    params[2] = a3;
+    return myst_syscall(n, params);
 }
 
 static __inline long __syscall4(long n, long a1, long a2, long a3, long a4)
 {
-	unsigned long ret;
-	register long r10 __asm__("r10") = a4;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
-						  "d"(a3), "r"(r10): "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    params[0] = a1;
+    params[1] = a2;
+    params[2] = a3;
+    params[3] = a4;
+    return myst_syscall(n, params);
 }
 
 static __inline long __syscall5(long n, long a1, long a2, long a3, long a4, long a5)
 {
-	unsigned long ret;
-	register long r10 __asm__("r10") = a4;
-	register long r8 __asm__("r8") = a5;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
-						  "d"(a3), "r"(r10), "r"(r8) : "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    params[0] = a1;
+    params[1] = a2;
+    params[2] = a3;
+    params[3] = a4;
+    params[4] = a5;
+    return myst_syscall(n, params);
 }
 
 static __inline long __syscall6(long n, long a1, long a2, long a3, long a4, long a5, long a6)
 {
-	unsigned long ret;
-	register long r10 __asm__("r10") = a4;
-	register long r8 __asm__("r8") = a5;
-	register long r9 __asm__("r9") = a6;
-	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
-						  "d"(a3), "r"(r10), "r"(r8), "r"(r9) : "rcx", "r11", "memory");
-	return ret;
+    long params[6] = { 0, 0, 0, 0, 0, 0 };
+    params[0] = a1;
+    params[1] = a2;
+    params[2] = a3;
+    params[3] = a4;
+    params[4] = a5;
+    params[5] = a6;
+    return myst_syscall(n, params);
 }
 
 #define VDSO_USEFUL
diff --git a/include/pthread.h b/include/pthread.h
index 984db680..9adecf2b 100644
--- a/include/pthread.h
+++ b/include/pthread.h
@@ -222,6 +222,10 @@ int pthread_getattr_default_np(pthread_attr_t *);
 int pthread_setattr_default_np(const pthread_attr_t *);
 int pthread_tryjoin_np(pthread_t, void **);
 int pthread_timedjoin_np(pthread_t, void **, const struct timespec *);
+int pthread_attr_setaffinity_np(pthread_attr_t *a,
+         size_t cpusetsize, const cpu_set_t *cpuset);
+int pthread_attr_getaffinity_np(pthread_attr_t *a,
+         size_t cpusetsize, cpu_set_t *cpuset);
 #endif
 
 #if _REDIR_TIME64
diff --git a/ldso/dlstart.c b/ldso/dlstart.c
index 20d50f2c..c6ad4096 100644
--- a/ldso/dlstart.c
+++ b/ldso/dlstart.c
@@ -1,4 +1,5 @@
 #include <stddef.h>
+#include <errno.h>
 #include "dynlink.h"
 #include "libc.h"
 
@@ -124,7 +125,6 @@ hidden void _dlstart_c(size_t *sp, size_t *dynv)
 			local_cnt = dynv[i+1];
 		for (i=0; i<local_cnt; i++) got[i] += base;
 	}
-
 	rel = (void *)(base+dyn[DT_REL]);
 	rel_size = dyn[DT_RELSZ];
 	for (; rel_size; rel+=2, rel_size-=2*sizeof(size_t)) {
@@ -146,3 +146,34 @@ hidden void _dlstart_c(size_t *sp, size_t *dynv)
 	GETFUNCSYM(&dls2, __dls2, base+dyn[DT_PLTGOT]);
 	dls2((void *)base, sp);
 }
+
+__attribute__((__weak__))
+void myst_trace(const char* msg)
+{
+}
+
+__attribute__((__weak__))
+void myst_trace_ptr(const char* msg, const void* ptr)
+{
+}
+
+__attribute__((__weak__))
+void myst_dump_argv(int argc, const char* argv[])
+{
+}
+
+__attribute__((__weak__))
+void myst_dump_stack(const void* stack)
+{
+}
+
+__attribute__((__weak__))
+void myst_load_symbols(void)
+{
+}
+
+__attribute__((__weak__))
+long myst_add_symbol_file(const char* path, const void* text, size_t text_size)
+{
+    return -ENOTSUP;
+}
diff --git a/ldso/dynlink.c b/ldso/dynlink.c
index afec985a..4cd45927 100644
--- a/ldso/dynlink.c
+++ b/ldso/dynlink.c
@@ -27,6 +27,13 @@
 
 static void error(const char *, ...);
 
+void myst_trace(const char* msg);
+void myst_load_symbols(void);
+long myst_add_symbol_file(
+    const char* path,
+    const void* text,
+    size_t text_size);
+
 #define MAXP2(a,b) (-(-(a)&-(b)))
 #define ALIGN(x,y) ((x)+(y)-1 & -(y))
 
@@ -1043,38 +1050,7 @@ static struct dso *load_library(const char *name, struct dso *needed_by)
 				fd = path_open(name, p->rpath, buf, sizeof buf);
 		}
 		if (fd == -1) {
-			if (!sys_path) {
-				char *prefix = 0;
-				size_t prefix_len;
-				if (ldso.name[0]=='/') {
-					char *s, *t, *z;
-					for (s=t=z=ldso.name; *s; s++)
-						if (*s=='/') z=t, t=s;
-					prefix_len = z-ldso.name;
-					if (prefix_len < PATH_MAX)
-						prefix = ldso.name;
-				}
-				if (!prefix) {
-					prefix = "";
-					prefix_len = 0;
-				}
-				char etc_ldso_path[prefix_len + 1
-					+ sizeof "/etc/ld-musl-" LDSO_ARCH ".path"];
-				snprintf(etc_ldso_path, sizeof etc_ldso_path,
-					"%.*s/etc/ld-musl-" LDSO_ARCH ".path",
-					(int)prefix_len, prefix);
-				FILE *f = fopen(etc_ldso_path, "rbe");
-				if (f) {
-					if (getdelim(&sys_path, (size_t[1]){0}, 0, f) <= 0) {
-						free(sys_path);
-						sys_path = "";
-					}
-					fclose(f);
-				} else if (errno != ENOENT) {
-					sys_path = "";
-				}
-			}
-			if (!sys_path) sys_path = "/lib:/usr/local/lib:/usr/lib";
+			if (!sys_path) sys_path = "/lib:/usr/local/lib:/usr/lib:/usr/lib/x86_64-linux-gnu:/lib/x86_64-linux-gnu";
 			fd = path_open(name, sys_path, buf, sizeof buf);
 		}
 		pathname = buf;
@@ -1098,6 +1074,7 @@ static struct dso *load_library(const char *name, struct dso *needed_by)
 	map = noload ? 0 : map_library(fd, &temp_dso);
 	close(fd);
 	if (!map) return 0;
+	myst_add_symbol_file(pathname, temp_dso.map, temp_dso.map_len);
 
 	/* Avoid the danger of getting two versions of libc mapped into the
 	 * same process when an absolute pathname was used. The symbols
@@ -1797,6 +1774,7 @@ void __dls3(size_t *sp, size_t *auxv)
 			dprintf(2, "%s: %s: Not a valid dynamic program\n", ldname, argv[0]);
 			_exit(1);
 		}
+	        myst_add_symbol_file(argv[0], app.map, app.map_len);
 		close(fd);
 		ldso.name = ldname;
 		app.name = argv[0];
@@ -1936,6 +1914,7 @@ void __dls3(size_t *sp, size_t *auxv)
 	/* Determine if malloc was interposed by a replacement implementation
 	 * so that calloc and the memalign family can harden against the
 	 * possibility of incomplete replacement. */
+
 	if (find_sym(head, "malloc", 1).dso != &ldso)
 		__malloc_replaced = 1;
 
@@ -1955,7 +1934,11 @@ void __dls3(size_t *sp, size_t *auxv)
 
 	errno = 0;
 
+        myst_trace("entering program");
+        myst_load_symbols();
+
 	CRTJMP((void *)aux[AT_ENTRY], argv-1);
+
 	for(;;);
 }
 
@@ -2100,6 +2083,7 @@ end:
 		free(ctor_queue);
 	}
 	pthread_setcancelstate(cs, 0);
+        myst_load_symbols();
 	return p;
 }
 
diff --git a/src/fenv/feupdateenv.c b/src/fenv/feupdateenv.c
index 50cef8e5..803a7f8d 100644
--- a/src/fenv/feupdateenv.c
+++ b/src/fenv/feupdateenv.c
@@ -7,3 +7,13 @@ int feupdateenv(const fenv_t *envp)
 	feraiseexcept(ex);
 	return 0;
 }
+
+int feenableexcept(int excepts)
+{
+	return 0;
+}
+
+int fedisableexcept(int excepts)
+{
+	return 0;
+}
diff --git a/src/include/pthread.h b/src/include/pthread.h
index 7167d3e1..9deca8e7 100644
--- a/src/include/pthread.h
+++ b/src/include/pthread.h
@@ -16,8 +16,8 @@ hidden int __pthread_mutex_timedlock(pthread_mutex_t *restrict, const struct tim
 hidden int __pthread_mutex_unlock(pthread_mutex_t *);
 hidden int __private_cond_signal(pthread_cond_t *, int);
 hidden int __pthread_cond_timedwait(pthread_cond_t *restrict, pthread_mutex_t *restrict, const struct timespec *restrict);
-hidden int __pthread_key_create(pthread_key_t *, void (*)(void *));
-hidden int __pthread_key_delete(pthread_key_t);
+int __pthread_key_create(pthread_key_t *, void (*)(void *));
+int __pthread_key_delete(pthread_key_t);
 hidden int __pthread_rwlock_rdlock(pthread_rwlock_t *);
 hidden int __pthread_rwlock_tryrdlock(pthread_rwlock_t *);
 hidden int __pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict);
diff --git a/src/include/time.h b/src/include/time.h
index cbabde47..4f94bc39 100644
--- a/src/include/time.h
+++ b/src/include/time.h
@@ -10,6 +10,6 @@ hidden char *__asctime_r(const struct tm *, char *);
 hidden struct tm *__gmtime_r(const time_t *restrict, struct tm *restrict);
 hidden struct tm *__localtime_r(const time_t *restrict, struct tm *restrict);
 
-hidden size_t __strftime_l(char *restrict, size_t, const char *restrict, const struct tm *restrict, locale_t);
+size_t __strftime_l(char *restrict, size_t, const char *restrict, const struct tm *restrict, locale_t);
 
 #endif
diff --git a/src/internal/pthread_impl.h b/src/internal/pthread_impl.h
index 5742dfc5..fe718786 100644
--- a/src/internal/pthread_impl.h
+++ b/src/internal/pthread_impl.h
@@ -75,7 +75,9 @@ struct __timer {
 #define _a_sched __u.__i[3*__SU+1]
 #define _a_policy __u.__i[3*__SU+2]
 #define _a_prio __u.__i[3*__SU+3]
-#define _m_type __u.__i[0]
+#define _a_cpuset __u.__s[5]
+#define _a_cpusetsize __u.__s[6]
+//#define _m_type __u.__i[0]
 #define _m_lock __u.__vi[1]
 #define _m_waiters __u.__vi[2]
 #define _m_prev __u.__p[3]
@@ -98,6 +100,61 @@ struct __timer {
 #define _b_waiters2 __u.__vi[4]
 #define _b_inst __u.__p[3]
 
+static __inline__ int _m_get_type(pthread_mutex_t* m)
+{
+    // The mutex type is given by or-ing the first and fifth 32-bit words of
+    // the mutex. The type is either set statically by a structure initializer
+    // or dynamically by pthread_mutex_init(). There are three cases:
+    //
+    //     1. The mutex is statically initialized by glibc, where the fifth
+    //        word contains the mutex type and the first word is zero.
+    //     2. The mutex is statically initialized by musl libc, where the
+    //        first word contains the mutex type and the fifth word is zero.
+    //     3. The mutex is dynamically initialized during pthread_mutex_init(),
+    //        where the first word contains the type and the fifth word is zero.
+    //
+    // Static initialization examples:
+    //
+    //     1. PTHREAD_MUTEX_INITIALIZER compiled with musl libc
+    //            m->__u.__i[0] is zero
+    //            m->__u.__i[4] is zero
+    //     2. PTHREAD_MUTEX_INITIALIZER compiled with glibc
+    //            m->__u.__i[0] is zero
+    //            m->__u.__i[4] contains PTHREAD_MUTEX_NORMAL (0)
+    //     3. PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP compiled with glibc
+    //            m->__u.__i[0] is zero
+    //            m->__u.__i[4] contains PTHREAD_MUTEX_RECURSIVE (1)
+    //     4. PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP compiled with glibc
+    //            m->__u.__i[0] is zero
+    //            m->__u.__i[4] contains PTHREAD_MUTEX_ERRORCHECK (2)
+    //     5. PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP compiled with glibc
+    //            m->__u.__i[0] is zero
+    //            m->__u.__i[4] contains PTHREAD_MUTEX_ADAPTIVE_NP (3)
+    //
+    // Note: must libc does not support PTHREAD_MUTEX_ADAPTIVE_NP.
+    //
+    // Note: that musl libc never uses the fourth and fifth words and keeps them
+    // as zero.
+
+    switch (m->__u.__i[4])
+    {
+        case PTHREAD_MUTEX_RECURSIVE:
+            return m->__u.__i[0] | PTHREAD_MUTEX_RECURSIVE;
+        case PTHREAD_MUTEX_ERRORCHECK:
+            return m->__u.__i[0] | PTHREAD_MUTEX_ERRORCHECK;
+        default:
+        {
+            // map glibc PTHREAD_MUTEX_ADAPTIVE_NP to PTHREAD_MUTEX_NORMAL
+            return m->__u.__i[0];
+        }
+    }
+}
+
+static __inline__ int _m_set_type(pthread_mutex_t* m, int type)
+{
+    m->__u.__i[0] = type;
+}
+
 #include "pthread_arch.h"
 
 #ifndef CANARY
diff --git a/src/linux/epoll.c b/src/linux/epoll.c
index deff5b10..fd66b82a 100644
--- a/src/linux/epoll.c
+++ b/src/linux/epoll.c
@@ -5,6 +5,11 @@
 
 int epoll_create(int size)
 {
+        if (size < 0)
+        {
+            errno = EINVAL;
+            return -1;
+        }
 	return epoll_create1(0);
 }
 
diff --git a/src/misc/setrlimit.c b/src/misc/setrlimit.c
index 7a66ab29..b6a2143b 100644
--- a/src/misc/setrlimit.c
+++ b/src/misc/setrlimit.c
@@ -39,7 +39,8 @@ static void do_setrlimit(void *p)
 int setrlimit(int resource, const struct rlimit *rlim)
 {
 	struct ctx c = { .res = resource, .rlim = rlim, .err = -1 };
-	__synccall(do_setrlimit, &c);
+	// __synccall(do_setrlimit, &c);
+	do_setrlimit(&c);
 	if (c.err) {
 		if (c.err>0) errno = c.err;
 		return -1;
diff --git a/src/misc/syscall.c b/src/misc/syscall.c
index 6f3ef656..614121c3 100644
--- a/src/misc/syscall.c
+++ b/src/misc/syscall.c
@@ -2,6 +2,7 @@
 #include <unistd.h>
 #include "syscall.h"
 #include <stdarg.h>
+#include <errno.h>
 
 #undef syscall
 
@@ -19,3 +20,28 @@ long syscall(long n, ...)
 	va_end(ap);
 	return __syscall_ret(__syscall(n,a,b,c,d,e,f));
 }
+
+__attribute__((__weak__))
+long myst_syscall(long n, long params[6])
+{
+    (void)n;
+    (void)params;
+    return EINVAL;
+}
+
+long myst_syscall_variadic(long n, ...)
+{
+    va_list ap;
+    long params[6];
+
+    va_start(ap, n);
+    params[0] = va_arg(ap, long);
+    params[1] = va_arg(ap, long);
+    params[2] = va_arg(ap, long);
+    params[3] = va_arg(ap, long);
+    params[4] = va_arg(ap, long);
+    params[5] = va_arg(ap, long);
+    va_end(ap);
+
+    return myst_syscall(n, params);
+}
diff --git a/src/network/res_init.c b/src/network/res_init.c
index 5dba9dfc..9b595a19 100644
--- a/src/network/res_init.c
+++ b/src/network/res_init.c
@@ -4,3 +4,5 @@ int res_init()
 {
 	return 0;
 }
+
+weak_alias(res_init, __res_init);
\ No newline at end of file
diff --git a/src/sched/affinity.c b/src/sched/affinity.c
index 948ece41..fd7e7801 100644
--- a/src/sched/affinity.c
+++ b/src/sched/affinity.c
@@ -31,3 +31,49 @@ int pthread_getaffinity_np(pthread_t td, size_t size, cpu_set_t *set)
 {
 	return -do_getaffinity(td->tid, size, set);
 }
+
+int pthread_attr_setaffinity_np(pthread_attr_t *a,
+         size_t cpusetsize, const cpu_set_t *cpuset)
+{
+	if ((!cpuset) || (cpusetsize==0)) 
+	{
+		if(a->_a_cpuset) free((void*)(a->_a_cpuset));
+		a->_a_cpuset = 0;
+		a->_a_cpusetsize = 0;
+	}
+	else
+	{
+		if(cpusetsize > a->_a_cpusetsize)
+		{
+			void* attr_cpuset;
+			if(!a->_a_cpuset)
+				attr_cpuset = malloc(cpusetsize);
+			else 
+				attr_cpuset = realloc((void*)(a->_a_cpuset), cpusetsize);
+			if (!attr_cpuset)
+				return ENOMEM;
+			else
+				a->_a_cpuset = (unsigned long)attr_cpuset;
+		}
+		memcpy((void*)(a->_a_cpuset), cpuset, cpusetsize);
+		a->_a_cpusetsize = cpusetsize;
+	}
+	return 0;
+}
+
+int pthread_attr_getaffinity_np(pthread_attr_t *a,
+         size_t cpusetsize, cpu_set_t *cpuset)
+{
+	if ((!cpuset) || (cpusetsize==0)) 
+	{
+		return EINVAL;
+	}
+	else if (cpusetsize < a->_a_cpusetsize)
+	{
+		return EINVAL;
+	}
+	memset(cpuset, 0, cpusetsize);
+	if (a->_a_cpuset)
+		memcpy(cpuset, (void*)a->_a_cpuset, a->_a_cpusetsize );
+	return 0;
+}
\ No newline at end of file
diff --git a/src/thread/__unmapself.c b/src/thread/__unmapself.c
index 31d94e67..e34cca2e 100644
--- a/src/thread/__unmapself.c
+++ b/src/thread/__unmapself.c
@@ -6,7 +6,7 @@
 
 static void *unmap_base;
 static size_t unmap_size;
-static char shared_stack[256];
+static char shared_stack[4096];
 
 static void do_unmap()
 {
diff --git a/src/thread/clone.c b/src/thread/clone.c
index be80c8ea..afc8d160 100644
--- a/src/thread/clone.c
+++ b/src/thread/clone.c
@@ -1,6 +1,7 @@
 #include <errno.h>
 #include "pthread_impl.h"
 
+weak
 int __clone(int (*func)(void *), void *stack, int flags, void *arg, ...)
 {
 	return -ENOSYS;
diff --git a/src/thread/mtx_init.c b/src/thread/mtx_init.c
index 4826f76b..b0d02ec4 100644
--- a/src/thread/mtx_init.c
+++ b/src/thread/mtx_init.c
@@ -3,8 +3,12 @@
 
 int mtx_init(mtx_t *m, int type)
 {
-	*m = (mtx_t){
-		._m_type = ((type&mtx_recursive) ? PTHREAD_MUTEX_RECURSIVE : PTHREAD_MUTEX_NORMAL),
-	};
+	*m = (mtx_t){0};
+
+        if ((type & mtx_recursive))
+            _m_set_type((pthread_mutex_t*)m, PTHREAD_MUTEX_RECURSIVE);
+        else
+            _m_set_type((pthread_mutex_t*)m, PTHREAD_MUTEX_NORMAL);
+
 	return thrd_success;
 }
diff --git a/src/thread/mtx_lock.c b/src/thread/mtx_lock.c
index 5c2415c1..823994fc 100644
--- a/src/thread/mtx_lock.c
+++ b/src/thread/mtx_lock.c
@@ -3,7 +3,7 @@
 
 int mtx_lock(mtx_t *m)
 {
-	if (m->_m_type == PTHREAD_MUTEX_NORMAL && !a_cas(&m->_m_lock, 0, EBUSY))
+	if (_m_get_type((pthread_mutex_t*)m) == PTHREAD_MUTEX_NORMAL && !a_cas(&m->_m_lock, 0, EBUSY))
 		return thrd_success;
 	/* Calling mtx_timedlock with a null pointer is an extension.
 	 * It is convenient, here to avoid duplication of the logic
diff --git a/src/thread/mtx_trylock.c b/src/thread/mtx_trylock.c
index 40a8b8c2..e57d1183 100644
--- a/src/thread/mtx_trylock.c
+++ b/src/thread/mtx_trylock.c
@@ -3,7 +3,7 @@
 
 int mtx_trylock(mtx_t *m)
 {
-	if (m->_m_type == PTHREAD_MUTEX_NORMAL)
+	if (_m_get_type((pthread_mutex_t*)m) == PTHREAD_MUTEX_NORMAL)
 		return (a_cas(&m->_m_lock, 0, EBUSY) & EBUSY) ? thrd_busy : thrd_success;
 
 	int ret = __pthread_mutex_trylock((pthread_mutex_t *)m);
diff --git a/src/thread/pthread_attr_destroy.c b/src/thread/pthread_attr_destroy.c
index b5845dd0..016dcfdd 100644
--- a/src/thread/pthread_attr_destroy.c
+++ b/src/thread/pthread_attr_destroy.c
@@ -2,5 +2,6 @@
 
 int pthread_attr_destroy(pthread_attr_t *a)
 {
+	if(a->_a_cpuset) free((void*)(a->_a_cpuset));
 	return 0;
-}
+}
\ No newline at end of file
diff --git a/src/thread/pthread_cancel.c b/src/thread/pthread_cancel.c
index 2f9d5e97..e4d3d000 100644
--- a/src/thread/pthread_cancel.c
+++ b/src/thread/pthread_cancel.c
@@ -14,9 +14,7 @@ long __cancel()
 	return -ECANCELED;
 }
 
-long __syscall_cp_asm(volatile void *, syscall_arg_t,
-                      syscall_arg_t, syscall_arg_t, syscall_arg_t,
-                      syscall_arg_t, syscall_arg_t, syscall_arg_t);
+long __syscall_cp_asm(volatile void* cancel, long n, long params[6]);
 
 long __syscall_cp_c(syscall_arg_t nr,
                     syscall_arg_t u, syscall_arg_t v, syscall_arg_t w,
@@ -30,7 +28,8 @@ long __syscall_cp_c(syscall_arg_t nr,
 	    && (st==PTHREAD_CANCEL_DISABLE || nr==SYS_close))
 		return __syscall(nr, u, v, w, x, y, z);
 
-	r = __syscall_cp_asm(&self->cancel, nr, u, v, w, x, y, z);
+        long params[6] = { u, v, w, x, y, z };
+	r = __syscall_cp_asm(&self->cancel, nr, params);
 	if (r==-EINTR && nr!=SYS_close && self->cancel &&
 	    self->canceldisable != PTHREAD_CANCEL_DISABLE)
 		r = __cancel();
@@ -56,7 +55,7 @@ static void cancel_handler(int sig, siginfo_t *si, void *ctx)
 
 	_sigaddset(&uc->uc_sigmask, SIGCANCEL);
 
-	if (self->cancelasync || pc >= (uintptr_t)__cp_begin && pc < (uintptr_t)__cp_end) {
+	if (pc >= (uintptr_t)__cp_begin && pc < (uintptr_t)__cp_end) {
 		uc->uc_mcontext.MC_PC = (uintptr_t)__cp_cancel;
 #ifdef CANCEL_GOT
 		uc->uc_mcontext.MC_GOT = CANCEL_GOT;
@@ -64,6 +63,7 @@ static void cancel_handler(int sig, siginfo_t *si, void *ctx)
 		return;
 	}
 
+	__cancel();
 	__syscall(SYS_tkill, self->tid, SIGCANCEL);
 }
 
diff --git a/src/thread/pthread_cond_timedwait.c b/src/thread/pthread_cond_timedwait.c
index d1501240..0b0a919d 100644
--- a/src/thread/pthread_cond_timedwait.c
+++ b/src/thread/pthread_cond_timedwait.c
@@ -65,7 +65,7 @@ int __pthread_cond_timedwait(pthread_cond_t *restrict c, pthread_mutex_t *restri
 	int e, seq, clock = c->_c_clock, cs, shared=0, oldstate, tmp;
 	volatile int *fut;
 
-	if ((m->_m_type&15) && (m->_m_lock&INT_MAX) != __pthread_self()->tid)
+	if ((_m_get_type(m)&15) && (m->_m_lock&INT_MAX) != __pthread_self()->tid)
 		return EPERM;
 
 	if (ts && ts->tv_nsec >= 1000000000UL)
@@ -151,7 +151,7 @@ relock:
 	/* Unlock the barrier that's holding back the next waiter, and
 	 * either wake it or requeue it to the mutex. */
 	if (node.prev)
-		unlock_requeue(&node.prev->barrier, &m->_m_lock, m->_m_type & 128);
+		unlock_requeue(&node.prev->barrier, &m->_m_lock, _m_get_type(m) & 128);
 	else
 		a_dec(&m->_m_waiters);
 
diff --git a/src/thread/pthread_create.c b/src/thread/pthread_create.c
index 5f491092..51c9fafb 100644
--- a/src/thread/pthread_create.c
+++ b/src/thread/pthread_create.c
@@ -108,7 +108,7 @@ _Noreturn void __pthread_exit(void *result)
 		pthread_mutex_t *m = (void *)((char *)rp
 			- offsetof(pthread_mutex_t, _m_next));
 		int waiters = m->_m_waiters;
-		int priv = (m->_m_type & 128) ^ 128;
+		int priv = (_m_get_type(m) & 128) ^ 128;
 		self->robust_list.pending = rp;
 		self->robust_list.head = *rp;
 		int cont = a_swap(&m->_m_lock, 0x40000000);
@@ -345,13 +345,21 @@ int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict att
 	 * clean up all transient resource usage before returning. */
 	if (ret < 0) {
 		ret = -EAGAIN;
-	} else if (attr._a_sched) {
-		ret = __syscall(SYS_sched_setscheduler,
-			new->tid, attr._a_policy, &attr._a_prio);
-		if (a_swap(&args->control, ret ? 3 : 0)==2)
-			__wake(&args->control, 1, 1);
-		if (ret)
-			__wait(&args->control, 0, 3, 0);
+	}
+	else {
+		if (attr._a_cpuset)
+		{
+			ret = __syscall(SYS_sched_setaffinity,
+				new->tid, attr._a_cpusetsize, attr._a_cpuset);
+		}
+		if ((ret>=0) && (attr._a_sched)) {
+			ret = __syscall(SYS_sched_setscheduler,
+				new->tid, attr._a_policy, &attr._a_prio);
+			if (a_swap(&args->control, ret ? 3 : 0)==2)
+				__wake(&args->control, 1, 1);
+			if (ret)
+				__wait(&args->control, 0, 3, 0);
+		}
 	}
 
 	if (ret >= 0) {
diff --git a/src/thread/pthread_mutex_consistent.c b/src/thread/pthread_mutex_consistent.c
index 27c74e5b..efadeec8 100644
--- a/src/thread/pthread_mutex_consistent.c
+++ b/src/thread/pthread_mutex_consistent.c
@@ -5,7 +5,7 @@ int pthread_mutex_consistent(pthread_mutex_t *m)
 {
 	int old = m->_m_lock;
 	int own = old & 0x3fffffff;
-	if (!(m->_m_type & 4) || !own || !(old & 0x40000000))
+	if (!(_m_get_type(m) & 4) || !own || !(old & 0x40000000))
 		return EINVAL;
 	if (own != __pthread_self()->tid)
 		return EPERM;
diff --git a/src/thread/pthread_mutex_init.c b/src/thread/pthread_mutex_init.c
index acf45a74..05108e52 100644
--- a/src/thread/pthread_mutex_init.c
+++ b/src/thread/pthread_mutex_init.c
@@ -3,6 +3,6 @@
 int pthread_mutex_init(pthread_mutex_t *restrict m, const pthread_mutexattr_t *restrict a)
 {
 	*m = (pthread_mutex_t){0};
-	if (a) m->_m_type = a->__attr;
+	if (a) _m_set_type(m, a->__attr);
 	return 0;
 }
diff --git a/src/thread/pthread_mutex_lock.c b/src/thread/pthread_mutex_lock.c
index 638d4b86..6562793a 100644
--- a/src/thread/pthread_mutex_lock.c
+++ b/src/thread/pthread_mutex_lock.c
@@ -2,7 +2,7 @@
 
 int __pthread_mutex_lock(pthread_mutex_t *m)
 {
-	if ((m->_m_type&15) == PTHREAD_MUTEX_NORMAL
+	if ((_m_get_type(m)&15) == PTHREAD_MUTEX_NORMAL
 	    && !a_cas(&m->_m_lock, 0, EBUSY))
 		return 0;
 
diff --git a/src/thread/pthread_mutex_timedlock.c b/src/thread/pthread_mutex_timedlock.c
index 9279fc54..243cb6c7 100644
--- a/src/thread/pthread_mutex_timedlock.c
+++ b/src/thread/pthread_mutex_timedlock.c
@@ -20,7 +20,7 @@ static int __futex4(volatile void *addr, int op, int val, const struct timespec
 
 static int pthread_mutex_timedlock_pi(pthread_mutex_t *restrict m, const struct timespec *restrict at)
 {
-	int type = m->_m_type;
+	int type = _m_get_type(m);
 	int priv = (type & 128) ^ 128;
 	pthread_t self = __pthread_self();
 	int e;
@@ -55,11 +55,11 @@ static int pthread_mutex_timedlock_pi(pthread_mutex_t *restrict m, const struct
 
 int __pthread_mutex_timedlock(pthread_mutex_t *restrict m, const struct timespec *restrict at)
 {
-	if ((m->_m_type&15) == PTHREAD_MUTEX_NORMAL
+	if ((_m_get_type(m)&15) == PTHREAD_MUTEX_NORMAL
 	    && !a_cas(&m->_m_lock, 0, EBUSY))
 		return 0;
 
-	int type = m->_m_type;
+	int type = _m_get_type(m);
 	int r, t, priv = (type & 128) ^ 128;
 
 	r = __pthread_mutex_trylock(m);
diff --git a/src/thread/pthread_mutex_trylock.c b/src/thread/pthread_mutex_trylock.c
index a24e7c58..9bac7411 100644
--- a/src/thread/pthread_mutex_trylock.c
+++ b/src/thread/pthread_mutex_trylock.c
@@ -3,7 +3,7 @@
 int __pthread_mutex_trylock_owner(pthread_mutex_t *m)
 {
 	int old, own;
-	int type = m->_m_type;
+	int type = _m_get_type(m);
 	pthread_t self = __pthread_self();
 	int tid = self->tid;
 
@@ -66,7 +66,7 @@ success:
 
 int __pthread_mutex_trylock(pthread_mutex_t *m)
 {
-	if ((m->_m_type&15) == PTHREAD_MUTEX_NORMAL)
+	if ((_m_get_type(m)&15) == PTHREAD_MUTEX_NORMAL)
 		return a_cas(&m->_m_lock, 0, EBUSY) & EBUSY;
 	return __pthread_mutex_trylock_owner(m);
 }
diff --git a/src/thread/pthread_mutex_unlock.c b/src/thread/pthread_mutex_unlock.c
index b66423e6..d9dfd608 100644
--- a/src/thread/pthread_mutex_unlock.c
+++ b/src/thread/pthread_mutex_unlock.c
@@ -5,8 +5,8 @@ int __pthread_mutex_unlock(pthread_mutex_t *m)
 	pthread_t self;
 	int waiters = m->_m_waiters;
 	int cont;
-	int type = m->_m_type & 15;
-	int priv = (m->_m_type & 128) ^ 128;
+	int type = _m_get_type(m) & 15;
+	int priv = (_m_get_type(m) & 128) ^ 128;
 	int new = 0;
 	int old;
 
diff --git a/src/thread/x86_64/__set_thread_area.s b/src/thread/x86_64/__set_thread_area.s
deleted file mode 100644
index 7347ff4d..00000000
--- a/src/thread/x86_64/__set_thread_area.s
+++ /dev/null
@@ -1,11 +0,0 @@
-/* Copyright 2011-2012 Nicholas J. Kain, licensed under standard MIT license */
-.text
-.global __set_thread_area
-.hidden __set_thread_area
-.type __set_thread_area,@function
-__set_thread_area:
-	mov %rdi,%rsi           /* shift for syscall */
-	movl $0x1002,%edi       /* SET_FS register */
-	movl $158,%eax          /* set fs segment to */
-	syscall                 /* arch_prctl(SET_FS, arg)*/
-	ret
diff --git a/src/thread/x86_64/__unmapself.s b/src/thread/x86_64/__unmapself.s
deleted file mode 100644
index e2689e65..00000000
--- a/src/thread/x86_64/__unmapself.s
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Copyright 2011-2012 Nicholas J. Kain, licensed under standard MIT license */
-.text
-.global __unmapself
-.type   __unmapself,@function
-__unmapself:
-	movl $11,%eax   /* SYS_munmap */
-	syscall         /* munmap(arg2,arg3) */
-	xor %rdi,%rdi   /* exit() args: always return success */
-	movl $60,%eax   /* SYS_exit */
-	syscall         /* exit(0) */
diff --git a/src/thread/x86_64/clone.s b/src/thread/x86_64/clone.s
deleted file mode 100644
index 6e47bc0a..00000000
--- a/src/thread/x86_64/clone.s
+++ /dev/null
@@ -1,28 +0,0 @@
-.text
-.global __clone
-.hidden __clone
-.type   __clone,@function
-__clone:
-	xor %eax,%eax
-	mov $56,%al
-	mov %rdi,%r11
-	mov %rdx,%rdi
-	mov %r8,%rdx
-	mov %r9,%r8
-	mov 8(%rsp),%r10
-	mov %r11,%r9
-	and $-16,%rsi
-	sub $8,%rsi
-	mov %rcx,(%rsi)
-	syscall
-	test %eax,%eax
-	jnz 1f
-	xor %ebp,%ebp
-	pop %rdi
-	call *%r9
-	mov %eax,%edi
-	xor %eax,%eax
-	mov $60,%al
-	syscall
-	hlt
-1:	ret
diff --git a/src/thread/x86_64/syscall_cp.s b/src/thread/x86_64/syscall_cp.s
index 4f101716..c6091da5 100644
--- a/src/thread/x86_64/syscall_cp.s
+++ b/src/thread/x86_64/syscall_cp.s
@@ -9,22 +9,19 @@
 .global __syscall_cp_asm
 .hidden __syscall_cp_asm
 .type   __syscall_cp_asm,@function
+// __syscall_cp_asm(%rdi=cancel, %rsi=n, %rdx=params)
 __syscall_cp_asm:
 
 __cp_begin:
 	mov (%rdi),%eax
 	test %eax,%eax
 	jnz __cp_cancel
+
 	mov %rdi,%r11
-	mov %rsi,%rax
-	mov %rdx,%rdi
-	mov %rcx,%rsi
-	mov %r8,%rdx
-	mov %r9,%r10
-	mov 8(%rsp),%r8
-	mov 16(%rsp),%r9
+        mov %rsi, %rdi
+        mov %rdx, %rsi
 	mov %r11,8(%rsp)
-	syscall
+	jmp myst_syscall
 __cp_end:
 	ret
 __cp_cancel:
diff --git a/src/internal/__popcountdi2.c b/src/internal/__popcountdi2.c
new file mode 100644
index 00000000..b4b374a1
--- /dev/null
+++ b/src/internal/__popcountdi2.c
@@ -0,0 +1,16 @@
+
+__attribute__((__weak__))
+int __popcountdi2(unsigned long a)
+{
+    unsigned long nbits = 0;
+
+    /* Count the number of bits that are set */
+    for (unsigned long i = 0; i < 64; i++)
+    {
+        if ((a & (1LU << i)))
+            nbits++;
+    }
+
+    /* Return 1 if the nbits is odd; return 0 if nbits is event */
+    return (nbits % 2) ? 1 : 0;
+}
diff --git a/src/stdio/__fprintf_chk.c b/src/stdio/__fprintf_chk.c
new file mode 100644
index 00000000..50253c11
--- /dev/null
+++ b/src/stdio/__fprintf_chk.c
@@ -0,0 +1,23 @@
+#include <stdio.h>
+#include <stdarg.h>
+
+extern int __vfprintf_chk(
+    FILE *stream,
+    int flag,
+    const char *format,
+    va_list ap);
+
+__attribute__((__weak__))
+int __fprintf_chk(FILE *stream, int flag, const char *format, ...)
+{
+    int ret;
+    va_list ap;
+
+    (void)flag;
+
+    va_start(ap, format);
+    ret = __vfprintf_chk(stream, flag, format, ap);
+    va_end(ap);
+
+    return ret;
+}
diff --git a/src/stdio/__vfprintf_chk.c b/src/stdio/__vfprintf_chk.c
new file mode 100644
index 00000000..5493e453
--- /dev/null
+++ b/src/stdio/__vfprintf_chk.c
@@ -0,0 +1,11 @@
+#include <stdio.h>
+#include <assert.h>
+
+__attribute__((__weak__))
+int __vfprintf_chk(FILE *stream, int flag, const char *format, va_list ap)
+{
+    assert(stream);
+    assert(format);
+    (void)flag;
+    return vfprintf(stream, format, ap);
+}
