# Getting started with a TEE-aware program

Please see [README](../README.md) for how to install Mystikos or build
it from source code.

This document guides users to create TEE-aware applications, which are
essential to many confidential computing scenarios.

## The problem statement

Why would an application want to be aware of the TEE it's running within? Two
possible requirements are:

* In an **isolated confidential computing** scenario, the application should
  behave differently based on whether it's running
  inside a TEE or not, and, if it is, which types of TEE;
* In a **collaborated confidential computing** scenario, the application wants
  to get help from the TEE, and gain trust to obtain secrets from an external
  party which enforces a policy such as only releasing keys to applications
  running inside a TEE with certain identities.

Why is **collaborated confidential computing** so important?
Imagine a doomsday scenario when the digital world has fallen: all routers/NICs
on the internet and all operating systems become untrustworthy, the
**collaborated confidential computing** would enable a group of
applications, serving as `safe harbors`, to collaborate and fight against
the malicious world.

## Mystikos solution

Mystikos provides two environment variables, `MYST_TARGET` and
`MYST_WANT_TLS_CREDENTIAL`, for TEE aware applications.

`MYST_TARGET` is read only, and applications can query the variable to
find out whether it is running outside or inside a TEE, and, when it's
running inside a TEE, which specific TEE platform it is.

When applications set `MYST_WANT_TLS_CREDENTIAL` to `1`, the Mystikos
runtime, as part of the booting process, will generate:

* a self-signed TLS certificate with root of trust from the
TEE; and
* an ephemeral private key corresponding to the public key embedded
in the certificate.

With both the certificate and the private key, the application can establish
an attested TLS channel with a peer, as long as the peer could perform
verification on the certificate and relate it to the root of trust from
the TEE. Now both parties can exchange secrets without the fear of
eavesdropping from malicious actors on the internet.

Furthermore, Mystikos provides two system calls, one for generating the above
mentioned certificate and private key, one for verifying the certificate,
for languages that support direct invocation of syscalls, such as C/C++.
These syscalls give application the flexibility to generate or verify as
many TLS certificates as possible at any time, without relying on
`MYST_WANT_TLS_CREDENTIAL`.

For applications written in high level languages which allow no direct
syscalls, FFI can be used to call into a native library that exposes such
system calls.

## Write a program that behaves differently for TEE and non-TEE

This example shows how to write a program that potentially performs secret
operations only when running inside a TEE.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    const char* target = getenv("MYST_TARGET");
    if ( !target )
    {
       printf("I am in unknown environment\n");
       return 1;
    }
    if (strcmp(target, "sgx") != 0)
    {
        printf("I am in non-TEE\n");\
        return 1;
    }

    printf("I am in SGX!  Now, for secrets!\n");
    // Perform secret operations below
    // ...

    return 0;
}
```

Save this to `tee.c`. You can build and run the program on Ubuntu with the
following commands:

```bash
gcc tee.c -o tee && ./tee
```
The output should be: `I am in unknown environment`.

Now build and run the program in SGX with the following commands:
```bash
mkdir appdir; myst-gcc tee.c -o appdir/tee
myst mkcpio appdir rootfs && myst exec rootfs /tee
```

The output should be: `I am in SGX`.

## Write a programs that generates/verifies self-signed certificates

This example shows how to generate TLS certificate and verify it using
system calls with C/C++. This is not interesting by itself because there
is no peers to establish trust with. For a peer-to-peer trusted channel
example, please check
[solutions attested_tls](https://github.com/deislabs/mystikos/tree/main/solutions/attested_tls).

A self-signed certificates generated by Mystikos includes:

* A public key for subsequent encrypted communications, and
* An attestation report containing:
    * The prove that the application is running in a specific TEE;
    * The application's identity; and
    * The hash of the communication public key.

When running with Mystikos, a application verifies the self-signed certificate
from a peer by issuing a syscall to Mystikos that:

1. extracts the public key and the attestation report;
1. checks if the attestation report is genuinely generated by a TEE;
1. checks if the hash of the public key matches the hash value inside
the attestation report;
1. checks if the application identity is expected. See `_verifier`
function below as an example.

```c
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <stdint.h>
#include <myst/tee.h>

int _verifier(myst_tee_identity_t* identity, void* ptr)
{
    // Expected Product ID: {1}
    const uint8_t PRODID[MYST_PRODUCT_ID_SIZE] = {1};
    // Expected security version: 1
    const int SVN = 1;

    // Returning 0 means pass.
    // We can easily expand this to more sophicated checks
    // based on unique_id, signer_id, etc.
    return memcmp(identity->product_id, PRODID, MYST_PRODUCT_ID_SIZE) ||
           identity->security_version != SVN;
}

int main()
{
    long ret;
    /* Extended syscalls */
    const long SYS_myst_gen_creds = 1009;
    const long SYS_myst_free_creds = 1010;
    const long SYS_myst_verify_cert = 1011;
    void* cert = NULL;
    void* pkey = NULL;
    size_t cert_size = 0, pkey_size = 0;

    ret = syscall(SYS_myst_gen_creds, &cert, &cert_size, &pkey, &pkey_size);
    assert(ret == 0);
    printf("Generated self-signed certificate and private key\n");

    ret = syscall(SYS_myst_verify_cert, cert, cert_size, _verifier, NULL);
    assert(ret == 0);
    printf("Verified self-signed certificate\n");

    ret = syscall(SYS_myst_free_creds, cert, cert_size, pkey, pkey_size);
    assert(ret == 0);

    return 0;
}
```

Save the file as `tee2.c`. Now build and run the program in SGX with the
following commands:
```bash
myst-gcc tee2.c -I/opt/mystikos/include -o appdir/tee2
myst mkcpio appdir rootfs && myst exec rootfs /tee2
```
And the output should be:
```
Generated self-signed certificate and private key
Verified self-signed certificate
```

The application is free to provide `NULL` for the third parameter of
`SYS_myst_verify_cert`. In that case, Mystikos would accept any
application running inside a TEE with no regard to the application identity.

If the application does want to reject/approve based on app identity, it
must include `myst/tee.h`, define a function similar to `_verifier`,
and pass it to syscall `SYS_myst_verify_cert`.
